// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Api.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - ITMApiRoot

@implementation ITMApiRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ITMApiRoot_FileDescriptor

static GPBFileDescriptor *ITMApiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"iterm2"
                                                 objcPrefix:@"ITM"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum ITMNotificationType

GPBEnumDescriptor *ITMNotificationType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NotifyOnKeystroke\000NotifyOnScreenUpdate\000N"
        "otifyOnPrompt\000NotifyOnLocationChange\000Not"
        "ifyOnCustomEscapeSequence\000NotifyOnNewSes"
        "sion\000NotifyOnTerminateSession\000NotifyOnLa"
        "youtChange\000NotifyOnFocusChange\000NotifyOnS"
        "erverOriginatedRpc\000NotifyOnBroadcastChan"
        "ge\000";
    static const int32_t values[] = {
        ITMNotificationType_NotifyOnKeystroke,
        ITMNotificationType_NotifyOnScreenUpdate,
        ITMNotificationType_NotifyOnPrompt,
        ITMNotificationType_NotifyOnLocationChange,
        ITMNotificationType_NotifyOnCustomEscapeSequence,
        ITMNotificationType_NotifyOnNewSession,
        ITMNotificationType_NotifyOnTerminateSession,
        ITMNotificationType_NotifyOnLayoutChange,
        ITMNotificationType_NotifyOnFocusChange,
        ITMNotificationType_NotifyOnServerOriginatedRpc,
        ITMNotificationType_NotifyOnBroadcastChange,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMNotificationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMNotificationType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMNotificationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMNotificationType_NotifyOnKeystroke:
    case ITMNotificationType_NotifyOnScreenUpdate:
    case ITMNotificationType_NotifyOnPrompt:
    case ITMNotificationType_NotifyOnLocationChange:
    case ITMNotificationType_NotifyOnCustomEscapeSequence:
    case ITMNotificationType_NotifyOnNewSession:
    case ITMNotificationType_NotifyOnTerminateSession:
    case ITMNotificationType_NotifyOnLayoutChange:
    case ITMNotificationType_NotifyOnFocusChange:
    case ITMNotificationType_NotifyOnServerOriginatedRpc:
    case ITMNotificationType_NotifyOnBroadcastChange:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ITMModifiers

GPBEnumDescriptor *ITMModifiers_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Control\000Option\000Command\000Shift\000Function\000Nu"
        "mpad\000";
    static const int32_t values[] = {
        ITMModifiers_Control,
        ITMModifiers_Option,
        ITMModifiers_Command,
        ITMModifiers_Shift,
        ITMModifiers_Function,
        ITMModifiers_Numpad,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMModifiers)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMModifiers_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMModifiers_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMModifiers_Control:
    case ITMModifiers_Option:
    case ITMModifiers_Command:
    case ITMModifiers_Shift:
    case ITMModifiers_Function:
    case ITMModifiers_Numpad:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMClientOriginatedMessage

@implementation ITMClientOriginatedMessage

@dynamic submessageOneOfCase;
@dynamic hasId_p, id_p;
@dynamic getBufferRequest;
@dynamic getPromptRequest;
@dynamic transactionRequest;
@dynamic notificationRequest;
@dynamic registerToolRequest;
@dynamic setProfilePropertyRequest;
@dynamic listSessionsRequest;
@dynamic sendTextRequest;
@dynamic createTabRequest;
@dynamic splitPaneRequest;
@dynamic getProfilePropertyRequest;
@dynamic setPropertyRequest;
@dynamic getPropertyRequest;
@dynamic injectRequest;
@dynamic activateRequest;
@dynamic variableRequest;
@dynamic savedArrangementRequest;
@dynamic focusRequest;
@dynamic listProfilesRequest;
@dynamic serverOriginatedRpcResultRequest;
@dynamic restartSessionRequest;
@dynamic menuItemRequest;
@dynamic setTabLayoutRequest;
@dynamic getBroadcastDomainsRequest;
@dynamic tmuxRequest;
@dynamic reorderTabsRequest;

typedef struct ITMClientOriginatedMessage__storage_ {
  uint32_t _has_storage_[2];
  ITMGetBufferRequest *getBufferRequest;
  ITMGetPromptRequest *getPromptRequest;
  ITMTransactionRequest *transactionRequest;
  ITMNotificationRequest *notificationRequest;
  ITMRegisterToolRequest *registerToolRequest;
  ITMSetProfilePropertyRequest *setProfilePropertyRequest;
  ITMListSessionsRequest *listSessionsRequest;
  ITMSendTextRequest *sendTextRequest;
  ITMCreateTabRequest *createTabRequest;
  ITMSplitPaneRequest *splitPaneRequest;
  ITMGetProfilePropertyRequest *getProfilePropertyRequest;
  ITMSetPropertyRequest *setPropertyRequest;
  ITMGetPropertyRequest *getPropertyRequest;
  ITMInjectRequest *injectRequest;
  ITMActivateRequest *activateRequest;
  ITMVariableRequest *variableRequest;
  ITMSavedArrangementRequest *savedArrangementRequest;
  ITMFocusRequest *focusRequest;
  ITMListProfilesRequest *listProfilesRequest;
  ITMServerOriginatedRPCResultRequest *serverOriginatedRpcResultRequest;
  ITMRestartSessionRequest *restartSessionRequest;
  ITMMenuItemRequest *menuItemRequest;
  ITMSetTabLayoutRequest *setTabLayoutRequest;
  ITMGetBroadcastDomainsRequest *getBroadcastDomainsRequest;
  ITMTmuxRequest *tmuxRequest;
  ITMReorderTabsRequest *reorderTabsRequest;
  int64_t id_p;
} ITMClientOriginatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ITMClientOriginatedMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "getBufferRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetBufferRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_GetBufferRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, getBufferRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPromptRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetPromptRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_GetPromptRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, getPromptRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTransactionRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_TransactionRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, transactionRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notificationRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMNotificationRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_NotificationRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, notificationRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "registerToolRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMRegisterToolRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_RegisterToolRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, registerToolRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setProfilePropertyRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetProfilePropertyRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SetProfilePropertyRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, setProfilePropertyRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listSessionsRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_ListSessionsRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, listSessionsRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendTextRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSendTextRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SendTextRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, sendTextRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createTabRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCreateTabRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_CreateTabRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, createTabRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "splitPaneRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSplitPaneRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SplitPaneRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, splitPaneRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getProfilePropertyRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetProfilePropertyRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_GetProfilePropertyRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, getProfilePropertyRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setPropertyRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetPropertyRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SetPropertyRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, setPropertyRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPropertyRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetPropertyRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_GetPropertyRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, getPropertyRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "injectRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMInjectRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_InjectRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, injectRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activateRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMActivateRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_ActivateRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, activateRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "variableRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMVariableRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_VariableRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, variableRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "savedArrangementRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSavedArrangementRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SavedArrangementRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, savedArrangementRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "focusRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_FocusRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, focusRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listProfilesRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListProfilesRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_ListProfilesRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, listProfilesRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverOriginatedRpcResultRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMServerOriginatedRPCResultRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_ServerOriginatedRpcResultRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, serverOriginatedRpcResultRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "restartSessionRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMRestartSessionRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_RestartSessionRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, restartSessionRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "menuItemRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMMenuItemRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_MenuItemRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, menuItemRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setTabLayoutRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetTabLayoutRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_SetTabLayoutRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, setTabLayoutRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getBroadcastDomainsRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetBroadcastDomainsRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_GetBroadcastDomainsRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, getBroadcastDomainsRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tmuxRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTmuxRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_TmuxRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, tmuxRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reorderTabsRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMReorderTabsRequest),
        .number = ITMClientOriginatedMessage_FieldNumber_ReorderTabsRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMClientOriginatedMessage__storage_, reorderTabsRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMClientOriginatedMessage class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMClientOriginatedMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "submessage",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMClientOriginatedMessage_ClearSubmessageOneOfCase(ITMClientOriginatedMessage *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMServerOriginatedMessage

@implementation ITMServerOriginatedMessage

@dynamic submessageOneOfCase;
@dynamic hasId_p, id_p;
@dynamic error;
@dynamic getBufferResponse;
@dynamic getPromptResponse;
@dynamic transactionResponse;
@dynamic notificationResponse;
@dynamic registerToolResponse;
@dynamic setProfilePropertyResponse;
@dynamic listSessionsResponse;
@dynamic sendTextResponse;
@dynamic createTabResponse;
@dynamic splitPaneResponse;
@dynamic getProfilePropertyResponse;
@dynamic setPropertyResponse;
@dynamic getPropertyResponse;
@dynamic injectResponse;
@dynamic activateResponse;
@dynamic variableResponse;
@dynamic savedArrangementResponse;
@dynamic focusResponse;
@dynamic listProfilesResponse;
@dynamic serverOriginatedRpcResultResponse;
@dynamic restartSessionResponse;
@dynamic menuItemResponse;
@dynamic setTabLayoutResponse;
@dynamic getBroadcastDomainsResponse;
@dynamic tmuxResponse;
@dynamic reorderTabsResponse;
@dynamic notification;

typedef struct ITMServerOriginatedMessage__storage_ {
  uint32_t _has_storage_[2];
  NSString *error;
  ITMGetBufferResponse *getBufferResponse;
  ITMGetPromptResponse *getPromptResponse;
  ITMTransactionResponse *transactionResponse;
  ITMNotificationResponse *notificationResponse;
  ITMRegisterToolResponse *registerToolResponse;
  ITMSetProfilePropertyResponse *setProfilePropertyResponse;
  ITMListSessionsResponse *listSessionsResponse;
  ITMSendTextResponse *sendTextResponse;
  ITMCreateTabResponse *createTabResponse;
  ITMSplitPaneResponse *splitPaneResponse;
  ITMGetProfilePropertyResponse *getProfilePropertyResponse;
  ITMSetPropertyResponse *setPropertyResponse;
  ITMGetPropertyResponse *getPropertyResponse;
  ITMInjectResponse *injectResponse;
  ITMActivateResponse *activateResponse;
  ITMVariableResponse *variableResponse;
  ITMSavedArrangementResponse *savedArrangementResponse;
  ITMFocusResponse *focusResponse;
  ITMListProfilesResponse *listProfilesResponse;
  ITMServerOriginatedRPCResultResponse *serverOriginatedRpcResultResponse;
  ITMRestartSessionResponse *restartSessionResponse;
  ITMMenuItemResponse *menuItemResponse;
  ITMSetTabLayoutResponse *setTabLayoutResponse;
  ITMGetBroadcastDomainsResponse *getBroadcastDomainsResponse;
  ITMTmuxResponse *tmuxResponse;
  ITMReorderTabsResponse *reorderTabsResponse;
  ITMNotification *notification;
  int64_t id_p;
} ITMServerOriginatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedMessage_FieldNumber_Error,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "getBufferResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetBufferResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_GetBufferResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, getBufferResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPromptResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetPromptResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_GetPromptResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, getPromptResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTransactionResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_TransactionResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, transactionResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notificationResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMNotificationResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_NotificationResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, notificationResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "registerToolResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMRegisterToolResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_RegisterToolResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, registerToolResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setProfilePropertyResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetProfilePropertyResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SetProfilePropertyResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, setProfilePropertyResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listSessionsResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_ListSessionsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, listSessionsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendTextResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSendTextResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SendTextResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, sendTextResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createTabResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCreateTabResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_CreateTabResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, createTabResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "splitPaneResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSplitPaneResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SplitPaneResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, splitPaneResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getProfilePropertyResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetProfilePropertyResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_GetProfilePropertyResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, getProfilePropertyResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setPropertyResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetPropertyResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SetPropertyResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, setPropertyResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPropertyResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetPropertyResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_GetPropertyResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, getPropertyResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "injectResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMInjectResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_InjectResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, injectResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activateResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMActivateResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_ActivateResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, activateResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "variableResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMVariableResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_VariableResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, variableResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "savedArrangementResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSavedArrangementResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SavedArrangementResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, savedArrangementResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "focusResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_FocusResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, focusResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listProfilesResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListProfilesResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_ListProfilesResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, listProfilesResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverOriginatedRpcResultResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMServerOriginatedRPCResultResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_ServerOriginatedRpcResultResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, serverOriginatedRpcResultResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "restartSessionResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMRestartSessionResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_RestartSessionResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, restartSessionResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "menuItemResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMMenuItemResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_MenuItemResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, menuItemResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setTabLayoutResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetTabLayoutResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_SetTabLayoutResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, setTabLayoutResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getBroadcastDomainsResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMGetBroadcastDomainsResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_GetBroadcastDomainsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, getBroadcastDomainsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tmuxResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTmuxResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_TmuxResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, tmuxResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reorderTabsResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMReorderTabsResponse),
        .number = ITMServerOriginatedMessage_FieldNumber_ReorderTabsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, reorderTabsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMNotification),
        .number = ITMServerOriginatedMessage_FieldNumber_Notification,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedMessage__storage_, notification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMServerOriginatedMessage class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMServerOriginatedMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "submessage",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMServerOriginatedMessage_ClearSubmessageOneOfCase(ITMServerOriginatedMessage *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMReorderTabsRequest

@implementation ITMReorderTabsRequest

@dynamic assignmentsArray, assignmentsArray_Count;

typedef struct ITMReorderTabsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *assignmentsArray;
} ITMReorderTabsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assignmentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMReorderTabsRequest_Assignment),
        .number = ITMReorderTabsRequest_FieldNumber_AssignmentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMReorderTabsRequest__storage_, assignmentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMReorderTabsRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMReorderTabsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMReorderTabsRequest_Assignment

@implementation ITMReorderTabsRequest_Assignment

@dynamic hasWindowId, windowId;
@dynamic tabIdsArray, tabIdsArray_Count;

typedef struct ITMReorderTabsRequest_Assignment__storage_ {
  uint32_t _has_storage_[1];
  NSString *windowId;
  NSMutableArray *tabIdsArray;
} ITMReorderTabsRequest_Assignment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMReorderTabsRequest_Assignment_FieldNumber_WindowId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMReorderTabsRequest_Assignment__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMReorderTabsRequest_Assignment_FieldNumber_TabIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMReorderTabsRequest_Assignment__storage_, tabIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMReorderTabsRequest_Assignment class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMReorderTabsRequest_Assignment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMReorderTabsRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMReorderTabsResponse

@implementation ITMReorderTabsResponse

@dynamic hasStatus, status;

typedef struct ITMReorderTabsResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMReorderTabsResponse_Status status;
} ITMReorderTabsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMReorderTabsResponse_Status_EnumDescriptor,
        .number = ITMReorderTabsResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMReorderTabsResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMReorderTabsResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMReorderTabsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMReorderTabsResponse_Status

GPBEnumDescriptor *ITMReorderTabsResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000InvalidAssignment\000InvalidWindowId\000Inv"
        "alidTabId\000";
    static const int32_t values[] = {
        ITMReorderTabsResponse_Status_Ok,
        ITMReorderTabsResponse_Status_InvalidAssignment,
        ITMReorderTabsResponse_Status_InvalidWindowId,
        ITMReorderTabsResponse_Status_InvalidTabId,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMReorderTabsResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMReorderTabsResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMReorderTabsResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMReorderTabsResponse_Status_Ok:
    case ITMReorderTabsResponse_Status_InvalidAssignment:
    case ITMReorderTabsResponse_Status_InvalidWindowId:
    case ITMReorderTabsResponse_Status_InvalidTabId:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMTmuxRequest

@implementation ITMTmuxRequest

@dynamic payloadOneOfCase;
@dynamic listConnections;
@dynamic sendCommand;
@dynamic setWindowVisible;

typedef struct ITMTmuxRequest__storage_ {
  uint32_t _has_storage_[2];
  ITMTmuxRequest_ListConnections *listConnections;
  ITMTmuxRequest_SendCommand *sendCommand;
  ITMTmuxRequest_SetWindowVisible *setWindowVisible;
} ITMTmuxRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listConnections",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTmuxRequest_ListConnections),
        .number = ITMTmuxRequest_FieldNumber_ListConnections,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMTmuxRequest__storage_, listConnections),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendCommand",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTmuxRequest_SendCommand),
        .number = ITMTmuxRequest_FieldNumber_SendCommand,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMTmuxRequest__storage_, sendCommand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setWindowVisible",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTmuxRequest_SetWindowVisible),
        .number = ITMTmuxRequest_FieldNumber_SetWindowVisible,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMTmuxRequest__storage_, setWindowVisible),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTmuxRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTmuxRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "payload",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMTmuxRequest_ClearPayloadOneOfCase(ITMTmuxRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMTmuxRequest_ListConnections

@implementation ITMTmuxRequest_ListConnections


typedef struct ITMTmuxRequest_ListConnections__storage_ {
  uint32_t _has_storage_[1];
} ITMTmuxRequest_ListConnections__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTmuxRequest_ListConnections class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ITMTmuxRequest_ListConnections__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMTmuxRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMTmuxRequest_SendCommand

@implementation ITMTmuxRequest_SendCommand

@dynamic hasConnectionId, connectionId;
@dynamic hasCommand, command;

typedef struct ITMTmuxRequest_SendCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *connectionId;
  NSString *command;
} ITMTmuxRequest_SendCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "connectionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMTmuxRequest_SendCommand_FieldNumber_ConnectionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMTmuxRequest_SendCommand__storage_, connectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "command",
        .dataTypeSpecific.className = NULL,
        .number = ITMTmuxRequest_SendCommand_FieldNumber_Command,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMTmuxRequest_SendCommand__storage_, command),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTmuxRequest_SendCommand class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTmuxRequest_SendCommand__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMTmuxRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMTmuxRequest_SetWindowVisible

@implementation ITMTmuxRequest_SetWindowVisible

@dynamic hasConnectionId, connectionId;
@dynamic hasWindowId, windowId;
@dynamic hasVisible, visible;

typedef struct ITMTmuxRequest_SetWindowVisible__storage_ {
  uint32_t _has_storage_[1];
  NSString *connectionId;
  NSString *windowId;
} ITMTmuxRequest_SetWindowVisible__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "connectionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMTmuxRequest_SetWindowVisible_FieldNumber_ConnectionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMTmuxRequest_SetWindowVisible__storage_, connectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMTmuxRequest_SetWindowVisible_FieldNumber_WindowId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMTmuxRequest_SetWindowVisible__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "visible",
        .dataTypeSpecific.className = NULL,
        .number = ITMTmuxRequest_SetWindowVisible_FieldNumber_Visible,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTmuxRequest_SetWindowVisible class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTmuxRequest_SetWindowVisible__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMTmuxRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMTmuxResponse

@implementation ITMTmuxResponse

@dynamic payloadOneOfCase;
@dynamic listConnections;
@dynamic sendCommand;
@dynamic setWindowVisible;
@dynamic hasStatus, status;

typedef struct ITMTmuxResponse__storage_ {
  uint32_t _has_storage_[2];
  ITMTmuxResponse_Status status;
  ITMTmuxResponse_ListConnections *listConnections;
  ITMTmuxResponse_SendCommand *sendCommand;
  ITMTmuxResponse_SetWindowVisible *setWindowVisible;
} ITMTmuxResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listConnections",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTmuxResponse_ListConnections),
        .number = ITMTmuxResponse_FieldNumber_ListConnections,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMTmuxResponse__storage_, listConnections),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendCommand",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTmuxResponse_SendCommand),
        .number = ITMTmuxResponse_FieldNumber_SendCommand,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMTmuxResponse__storage_, sendCommand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setWindowVisible",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTmuxResponse_SetWindowVisible),
        .number = ITMTmuxResponse_FieldNumber_SetWindowVisible,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMTmuxResponse__storage_, setWindowVisible),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMTmuxResponse_Status_EnumDescriptor,
        .number = ITMTmuxResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMTmuxResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTmuxResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTmuxResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "payload",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMTmuxResponse_ClearPayloadOneOfCase(ITMTmuxResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Enum ITMTmuxResponse_Status

GPBEnumDescriptor *ITMTmuxResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000InvalidRequest\000InvalidConnectionId\000In"
        "validWindowId\000";
    static const int32_t values[] = {
        ITMTmuxResponse_Status_Ok,
        ITMTmuxResponse_Status_InvalidRequest,
        ITMTmuxResponse_Status_InvalidConnectionId,
        ITMTmuxResponse_Status_InvalidWindowId,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMTmuxResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMTmuxResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMTmuxResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMTmuxResponse_Status_Ok:
    case ITMTmuxResponse_Status_InvalidRequest:
    case ITMTmuxResponse_Status_InvalidConnectionId:
    case ITMTmuxResponse_Status_InvalidWindowId:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMTmuxResponse_ListConnections

@implementation ITMTmuxResponse_ListConnections

@dynamic connectionsArray, connectionsArray_Count;

typedef struct ITMTmuxResponse_ListConnections__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *connectionsArray;
} ITMTmuxResponse_ListConnections__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "connectionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTmuxResponse_ListConnections_Connection),
        .number = ITMTmuxResponse_ListConnections_FieldNumber_ConnectionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMTmuxResponse_ListConnections__storage_, connectionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTmuxResponse_ListConnections class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTmuxResponse_ListConnections__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMTmuxResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMTmuxResponse_ListConnections_Connection

@implementation ITMTmuxResponse_ListConnections_Connection

@dynamic hasConnectionId, connectionId;
@dynamic hasOwningSessionId, owningSessionId;

typedef struct ITMTmuxResponse_ListConnections_Connection__storage_ {
  uint32_t _has_storage_[1];
  NSString *connectionId;
  NSString *owningSessionId;
} ITMTmuxResponse_ListConnections_Connection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "connectionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMTmuxResponse_ListConnections_Connection_FieldNumber_ConnectionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMTmuxResponse_ListConnections_Connection__storage_, connectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "owningSessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMTmuxResponse_ListConnections_Connection_FieldNumber_OwningSessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMTmuxResponse_ListConnections_Connection__storage_, owningSessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTmuxResponse_ListConnections_Connection class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTmuxResponse_ListConnections_Connection__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMTmuxResponse_ListConnections)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMTmuxResponse_SendCommand

@implementation ITMTmuxResponse_SendCommand

@dynamic hasOutput, output;

typedef struct ITMTmuxResponse_SendCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *output;
} ITMTmuxResponse_SendCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "output",
        .dataTypeSpecific.className = NULL,
        .number = ITMTmuxResponse_SendCommand_FieldNumber_Output,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMTmuxResponse_SendCommand__storage_, output),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTmuxResponse_SendCommand class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTmuxResponse_SendCommand__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMTmuxResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMTmuxResponse_SetWindowVisible

@implementation ITMTmuxResponse_SetWindowVisible


typedef struct ITMTmuxResponse_SetWindowVisible__storage_ {
  uint32_t _has_storage_[1];
} ITMTmuxResponse_SetWindowVisible__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTmuxResponse_SetWindowVisible class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ITMTmuxResponse_SetWindowVisible__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMTmuxResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetBroadcastDomainsRequest

@implementation ITMGetBroadcastDomainsRequest


typedef struct ITMGetBroadcastDomainsRequest__storage_ {
  uint32_t _has_storage_[1];
} ITMGetBroadcastDomainsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetBroadcastDomainsRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ITMGetBroadcastDomainsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMBroadcastDomain

@implementation ITMBroadcastDomain

@dynamic sessionIdsArray, sessionIdsArray_Count;

typedef struct ITMBroadcastDomain__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *sessionIdsArray;
} ITMBroadcastDomain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMBroadcastDomain_FieldNumber_SessionIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMBroadcastDomain__storage_, sessionIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMBroadcastDomain class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMBroadcastDomain__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetBroadcastDomainsResponse

@implementation ITMGetBroadcastDomainsResponse

@dynamic broadcastDomainsArray, broadcastDomainsArray_Count;

typedef struct ITMGetBroadcastDomainsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *broadcastDomainsArray;
} ITMGetBroadcastDomainsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "broadcastDomainsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMBroadcastDomain),
        .number = ITMGetBroadcastDomainsResponse_FieldNumber_BroadcastDomainsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMGetBroadcastDomainsResponse__storage_, broadcastDomainsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetBroadcastDomainsResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetBroadcastDomainsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSetTabLayoutRequest

@implementation ITMSetTabLayoutRequest

@dynamic hasRoot, root;
@dynamic hasTabId, tabId;

typedef struct ITMSetTabLayoutRequest__storage_ {
  uint32_t _has_storage_[1];
  ITMSplitTreeNode *root;
  NSString *tabId;
} ITMSetTabLayoutRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "root",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSplitTreeNode),
        .number = ITMSetTabLayoutRequest_FieldNumber_Root,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetTabLayoutRequest__storage_, root),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tabId",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetTabLayoutRequest_FieldNumber_TabId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSetTabLayoutRequest__storage_, tabId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetTabLayoutRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetTabLayoutRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSetTabLayoutResponse

@implementation ITMSetTabLayoutResponse

@dynamic hasStatus, status;

typedef struct ITMSetTabLayoutResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSetTabLayoutResponse_Status status;
} ITMSetTabLayoutResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSetTabLayoutResponse_Status_EnumDescriptor,
        .number = ITMSetTabLayoutResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetTabLayoutResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetTabLayoutResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetTabLayoutResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSetTabLayoutResponse_Status

GPBEnumDescriptor *ITMSetTabLayoutResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000BadTabId\000WrongTree\000InvalidSize\000";
    static const int32_t values[] = {
        ITMSetTabLayoutResponse_Status_Ok,
        ITMSetTabLayoutResponse_Status_BadTabId,
        ITMSetTabLayoutResponse_Status_WrongTree,
        ITMSetTabLayoutResponse_Status_InvalidSize,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSetTabLayoutResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSetTabLayoutResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSetTabLayoutResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSetTabLayoutResponse_Status_Ok:
    case ITMSetTabLayoutResponse_Status_BadTabId:
    case ITMSetTabLayoutResponse_Status_WrongTree:
    case ITMSetTabLayoutResponse_Status_InvalidSize:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMMenuItemRequest

@implementation ITMMenuItemRequest

@dynamic hasIdentifier, identifier;
@dynamic hasQueryOnly, queryOnly;

typedef struct ITMMenuItemRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
} ITMMenuItemRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = ITMMenuItemRequest_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMMenuItemRequest__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "queryOnly",
        .dataTypeSpecific.className = NULL,
        .number = ITMMenuItemRequest_FieldNumber_QueryOnly,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMMenuItemRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMMenuItemRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMMenuItemResponse

@implementation ITMMenuItemResponse

@dynamic hasStatus, status;
@dynamic hasChecked, checked;
@dynamic hasEnabled, enabled;

typedef struct ITMMenuItemResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMMenuItemResponse_Status status;
} ITMMenuItemResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMMenuItemResponse_Status_EnumDescriptor,
        .number = ITMMenuItemResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMMenuItemResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "checked",
        .dataTypeSpecific.className = NULL,
        .number = ITMMenuItemResponse_FieldNumber_Checked,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "enabled",
        .dataTypeSpecific.className = NULL,
        .number = ITMMenuItemResponse_FieldNumber_Enabled,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMMenuItemResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMMenuItemResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMMenuItemResponse_Status

GPBEnumDescriptor *ITMMenuItemResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000BadIdentifier\000Disabled\000";
    static const int32_t values[] = {
        ITMMenuItemResponse_Status_Ok,
        ITMMenuItemResponse_Status_BadIdentifier,
        ITMMenuItemResponse_Status_Disabled,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMMenuItemResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMMenuItemResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMMenuItemResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMMenuItemResponse_Status_Ok:
    case ITMMenuItemResponse_Status_BadIdentifier:
    case ITMMenuItemResponse_Status_Disabled:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMRestartSessionRequest

@implementation ITMRestartSessionRequest

@dynamic hasSessionId, sessionId;
@dynamic hasOnlyIfExited, onlyIfExited;

typedef struct ITMRestartSessionRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
} ITMRestartSessionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMRestartSessionRequest_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRestartSessionRequest__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onlyIfExited",
        .dataTypeSpecific.className = NULL,
        .number = ITMRestartSessionRequest_FieldNumber_OnlyIfExited,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRestartSessionRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRestartSessionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMRestartSessionResponse

@implementation ITMRestartSessionResponse

@dynamic hasStatus, status;

typedef struct ITMRestartSessionResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMRestartSessionResponse_Status status;
} ITMRestartSessionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMRestartSessionResponse_Status_EnumDescriptor,
        .number = ITMRestartSessionResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRestartSessionResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRestartSessionResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRestartSessionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMRestartSessionResponse_Status

GPBEnumDescriptor *ITMRestartSessionResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000SessionNotRestartable"
        "\000";
    static const int32_t values[] = {
        ITMRestartSessionResponse_Status_Ok,
        ITMRestartSessionResponse_Status_SessionNotFound,
        ITMRestartSessionResponse_Status_SessionNotRestartable,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMRestartSessionResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMRestartSessionResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMRestartSessionResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMRestartSessionResponse_Status_Ok:
    case ITMRestartSessionResponse_Status_SessionNotFound:
    case ITMRestartSessionResponse_Status_SessionNotRestartable:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMServerOriginatedRPCResultRequest

@implementation ITMServerOriginatedRPCResultRequest

@dynamic resultOneOfCase;
@dynamic hasRequestId, requestId;
@dynamic jsonException;
@dynamic jsonValue;

typedef struct ITMServerOriginatedRPCResultRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *requestId;
  NSString *jsonException;
  NSString *jsonValue;
} ITMServerOriginatedRPCResultRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedRPCResultRequest_FieldNumber_RequestId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMServerOriginatedRPCResultRequest__storage_, requestId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonException",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedRPCResultRequest_FieldNumber_JsonException,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedRPCResultRequest__storage_, jsonException),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedRPCResultRequest_FieldNumber_JsonValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedRPCResultRequest__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMServerOriginatedRPCResultRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMServerOriginatedRPCResultRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMServerOriginatedRPCResultRequest_ClearResultOneOfCase(ITMServerOriginatedRPCResultRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMServerOriginatedRPCResultResponse

@implementation ITMServerOriginatedRPCResultResponse


typedef struct ITMServerOriginatedRPCResultResponse__storage_ {
  uint32_t _has_storage_[1];
} ITMServerOriginatedRPCResultResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMServerOriginatedRPCResultResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ITMServerOriginatedRPCResultResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListProfilesRequest

@implementation ITMListProfilesRequest

@dynamic propertiesArray, propertiesArray_Count;
@dynamic guidsArray, guidsArray_Count;

typedef struct ITMListProfilesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *propertiesArray;
  NSMutableArray *guidsArray;
} ITMListProfilesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "propertiesArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMListProfilesRequest_FieldNumber_PropertiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListProfilesRequest__storage_, propertiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "guidsArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMListProfilesRequest_FieldNumber_GuidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListProfilesRequest__storage_, guidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListProfilesRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListProfilesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListProfilesResponse

@implementation ITMListProfilesResponse

@dynamic profilesArray, profilesArray_Count;

typedef struct ITMListProfilesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *profilesArray;
} ITMListProfilesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "profilesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListProfilesResponse_Profile),
        .number = ITMListProfilesResponse_FieldNumber_ProfilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListProfilesResponse__storage_, profilesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListProfilesResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListProfilesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListProfilesResponse_Profile

@implementation ITMListProfilesResponse_Profile

@dynamic propertiesArray, propertiesArray_Count;

typedef struct ITMListProfilesResponse_Profile__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *propertiesArray;
} ITMListProfilesResponse_Profile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "propertiesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMProfileProperty),
        .number = ITMListProfilesResponse_Profile_FieldNumber_PropertiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListProfilesResponse_Profile__storage_, propertiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListProfilesResponse_Profile class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListProfilesResponse_Profile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMListProfilesResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMFocusRequest

@implementation ITMFocusRequest


typedef struct ITMFocusRequest__storage_ {
  uint32_t _has_storage_[1];
} ITMFocusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFocusRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ITMFocusRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMFocusResponse

@implementation ITMFocusResponse

@dynamic notificationsArray, notificationsArray_Count;

typedef struct ITMFocusResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *notificationsArray;
} ITMFocusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusChangedNotification),
        .number = ITMFocusResponse_FieldNumber_NotificationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMFocusResponse__storage_, notificationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFocusResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMFocusResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSavedArrangementRequest

@implementation ITMSavedArrangementRequest

@dynamic hasName, name;
@dynamic hasAction, action;
@dynamic hasWindowId, windowId;

typedef struct ITMSavedArrangementRequest__storage_ {
  uint32_t _has_storage_[1];
  ITMSavedArrangementRequest_Action action;
  NSString *name;
  NSString *windowId;
} ITMSavedArrangementRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMSavedArrangementRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSavedArrangementRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = ITMSavedArrangementRequest_Action_EnumDescriptor,
        .number = ITMSavedArrangementRequest_FieldNumber_Action,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSavedArrangementRequest__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMSavedArrangementRequest_FieldNumber_WindowId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMSavedArrangementRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSavedArrangementRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSavedArrangementRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSavedArrangementRequest_Action

GPBEnumDescriptor *ITMSavedArrangementRequest_Action_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Restore\000Save\000";
    static const int32_t values[] = {
        ITMSavedArrangementRequest_Action_Restore,
        ITMSavedArrangementRequest_Action_Save,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSavedArrangementRequest_Action)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSavedArrangementRequest_Action_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSavedArrangementRequest_Action_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSavedArrangementRequest_Action_Restore:
    case ITMSavedArrangementRequest_Action_Save:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSavedArrangementResponse

@implementation ITMSavedArrangementResponse

@dynamic hasStatus, status;

typedef struct ITMSavedArrangementResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSavedArrangementResponse_Status status;
} ITMSavedArrangementResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSavedArrangementResponse_Status_EnumDescriptor,
        .number = ITMSavedArrangementResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSavedArrangementResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSavedArrangementResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSavedArrangementResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSavedArrangementResponse_Status

GPBEnumDescriptor *ITMSavedArrangementResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000ArrangementNotFound\000WindowNotFound\000Re"
        "questMalformed\000";
    static const int32_t values[] = {
        ITMSavedArrangementResponse_Status_Ok,
        ITMSavedArrangementResponse_Status_ArrangementNotFound,
        ITMSavedArrangementResponse_Status_WindowNotFound,
        ITMSavedArrangementResponse_Status_RequestMalformed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSavedArrangementResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSavedArrangementResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSavedArrangementResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSavedArrangementResponse_Status_Ok:
    case ITMSavedArrangementResponse_Status_ArrangementNotFound:
    case ITMSavedArrangementResponse_Status_WindowNotFound:
    case ITMSavedArrangementResponse_Status_RequestMalformed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMVariableRequest

@implementation ITMVariableRequest

@dynamic scopeOneOfCase;
@dynamic sessionId;
@dynamic tabId;
@dynamic app;
@dynamic setArray, setArray_Count;
@dynamic getArray, getArray_Count;

typedef struct ITMVariableRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *sessionId;
  NSMutableArray *setArray;
  NSMutableArray *getArray;
  NSString *tabId;
} ITMVariableRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_FieldNumber_SessionId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMVariableRequest__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "setArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMVariableRequest_Set),
        .number = ITMVariableRequest_FieldNumber_SetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMVariableRequest__storage_, setArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_FieldNumber_GetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMVariableRequest__storage_, getArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabId",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_FieldNumber_TabId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMVariableRequest__storage_, tabId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "app",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_FieldNumber_App,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMVariableRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMVariableRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "scope",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMVariableRequest_ClearScopeOneOfCase(ITMVariableRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMVariableRequest_Set

@implementation ITMVariableRequest_Set

@dynamic hasName, name;
@dynamic hasValue, value;

typedef struct ITMVariableRequest_Set__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *value;
} ITMVariableRequest_Set__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_Set_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMVariableRequest_Set__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableRequest_Set_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMVariableRequest_Set__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMVariableRequest_Set class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMVariableRequest_Set__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMVariableRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMVariableResponse

@implementation ITMVariableResponse

@dynamic hasStatus, status;
@dynamic valuesArray, valuesArray_Count;

typedef struct ITMVariableResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMVariableResponse_Status status;
  NSMutableArray *valuesArray;
} ITMVariableResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMVariableResponse_Status_EnumDescriptor,
        .number = ITMVariableResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMVariableResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMVariableResponse_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMVariableResponse__storage_, valuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMVariableResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMVariableResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMVariableResponse_Status

GPBEnumDescriptor *ITMVariableResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000InvalidName\000MissingSc"
        "ope\000TabNotFound\000MultiGetDisallowed\000";
    static const int32_t values[] = {
        ITMVariableResponse_Status_Ok,
        ITMVariableResponse_Status_SessionNotFound,
        ITMVariableResponse_Status_InvalidName,
        ITMVariableResponse_Status_MissingScope,
        ITMVariableResponse_Status_TabNotFound,
        ITMVariableResponse_Status_MultiGetDisallowed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMVariableResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMVariableResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMVariableResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMVariableResponse_Status_Ok:
    case ITMVariableResponse_Status_SessionNotFound:
    case ITMVariableResponse_Status_InvalidName:
    case ITMVariableResponse_Status_MissingScope:
    case ITMVariableResponse_Status_TabNotFound:
    case ITMVariableResponse_Status_MultiGetDisallowed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMActivateRequest

@implementation ITMActivateRequest

@dynamic identifierOneOfCase;
@dynamic windowId;
@dynamic tabId;
@dynamic sessionId;
@dynamic hasOrderWindowFront, orderWindowFront;
@dynamic hasSelectTab, selectTab;
@dynamic hasSelectSession, selectSession;
@dynamic hasActivateApp, activateApp;

typedef struct ITMActivateRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *windowId;
  NSString *tabId;
  NSString *sessionId;
  ITMActivateRequest_App *activateApp;
} ITMActivateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_WindowId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMActivateRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabId",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_TabId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMActivateRequest__storage_, tabId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_SessionId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMActivateRequest__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderWindowFront",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_OrderWindowFront,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "selectTab",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_SelectTab,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "selectSession",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_FieldNumber_SelectSession,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "activateApp",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMActivateRequest_App),
        .number = ITMActivateRequest_FieldNumber_ActivateApp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ITMActivateRequest__storage_, activateApp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMActivateRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMActivateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "identifier",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMActivateRequest_ClearIdentifierOneOfCase(ITMActivateRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMActivateRequest_App

@implementation ITMActivateRequest_App

@dynamic hasRaiseAllWindows, raiseAllWindows;
@dynamic hasIgnoringOtherApps, ignoringOtherApps;

typedef struct ITMActivateRequest_App__storage_ {
  uint32_t _has_storage_[1];
} ITMActivateRequest_App__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "raiseAllWindows",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_App_FieldNumber_RaiseAllWindows,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ignoringOtherApps",
        .dataTypeSpecific.className = NULL,
        .number = ITMActivateRequest_App_FieldNumber_IgnoringOtherApps,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMActivateRequest_App class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMActivateRequest_App__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMActivateRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMActivateResponse

@implementation ITMActivateResponse

@dynamic hasStatus, status;

typedef struct ITMActivateResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMActivateResponse_Status status;
} ITMActivateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMActivateResponse_Status_EnumDescriptor,
        .number = ITMActivateResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMActivateResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMActivateResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMActivateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMActivateResponse_Status

GPBEnumDescriptor *ITMActivateResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000BadIdentifier\000InvalidOption\000";
    static const int32_t values[] = {
        ITMActivateResponse_Status_Ok,
        ITMActivateResponse_Status_BadIdentifier,
        ITMActivateResponse_Status_InvalidOption,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMActivateResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMActivateResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMActivateResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMActivateResponse_Status_Ok:
    case ITMActivateResponse_Status_BadIdentifier:
    case ITMActivateResponse_Status_InvalidOption:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMInjectRequest

@implementation ITMInjectRequest

@dynamic sessionIdArray, sessionIdArray_Count;
@dynamic hasData_p, data_p;

typedef struct ITMInjectRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *sessionIdArray;
  NSData *data_p;
} ITMInjectRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionIdArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMInjectRequest_FieldNumber_SessionIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMInjectRequest__storage_, sessionIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = ITMInjectRequest_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMInjectRequest__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMInjectRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMInjectRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMInjectResponse

@implementation ITMInjectResponse

@dynamic statusArray, statusArray_Count;

typedef struct ITMInjectResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *statusArray;
} ITMInjectResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusArray",
        .dataTypeSpecific.enumDescFunc = ITMInjectResponse_Status_EnumDescriptor,
        .number = ITMInjectResponse_FieldNumber_StatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMInjectResponse__storage_, statusArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMInjectResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMInjectResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMInjectResponse_Status

GPBEnumDescriptor *ITMInjectResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000";
    static const int32_t values[] = {
        ITMInjectResponse_Status_Ok,
        ITMInjectResponse_Status_SessionNotFound,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMInjectResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMInjectResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMInjectResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMInjectResponse_Status_Ok:
    case ITMInjectResponse_Status_SessionNotFound:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMGetPropertyRequest

@implementation ITMGetPropertyRequest

@dynamic identifierOneOfCase;
@dynamic windowId;
@dynamic sessionId;
@dynamic hasName, name;

typedef struct ITMGetPropertyRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *windowId;
  NSString *name;
  NSString *sessionId;
} ITMGetPropertyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPropertyRequest_FieldNumber_WindowId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMGetPropertyRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPropertyRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetPropertyRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPropertyRequest_FieldNumber_SessionId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMGetPropertyRequest__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetPropertyRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetPropertyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "identifier",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMGetPropertyRequest_ClearIdentifierOneOfCase(ITMGetPropertyRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMGetPropertyResponse

@implementation ITMGetPropertyResponse

@dynamic hasStatus, status;
@dynamic hasJsonValue, jsonValue;

typedef struct ITMGetPropertyResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMGetPropertyResponse_Status status;
  NSString *jsonValue;
} ITMGetPropertyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMGetPropertyResponse_Status_EnumDescriptor,
        .number = ITMGetPropertyResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetPropertyResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPropertyResponse_FieldNumber_JsonValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMGetPropertyResponse__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetPropertyResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetPropertyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMGetPropertyResponse_Status

GPBEnumDescriptor *ITMGetPropertyResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000UnrecognizedName\000InvalidTarget\000";
    static const int32_t values[] = {
        ITMGetPropertyResponse_Status_Ok,
        ITMGetPropertyResponse_Status_UnrecognizedName,
        ITMGetPropertyResponse_Status_InvalidTarget,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMGetPropertyResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMGetPropertyResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMGetPropertyResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMGetPropertyResponse_Status_Ok:
    case ITMGetPropertyResponse_Status_UnrecognizedName:
    case ITMGetPropertyResponse_Status_InvalidTarget:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSetPropertyRequest

@implementation ITMSetPropertyRequest

@dynamic identifierOneOfCase;
@dynamic windowId;
@dynamic sessionId;
@dynamic hasName, name;
@dynamic hasJsonValue, jsonValue;

typedef struct ITMSetPropertyRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *windowId;
  NSString *name;
  NSString *jsonValue;
  NSString *sessionId;
} ITMSetPropertyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetPropertyRequest_FieldNumber_WindowId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMSetPropertyRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetPropertyRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetPropertyRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetPropertyRequest_FieldNumber_JsonValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSetPropertyRequest__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetPropertyRequest_FieldNumber_SessionId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMSetPropertyRequest__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetPropertyRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetPropertyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "identifier",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMSetPropertyRequest_ClearIdentifierOneOfCase(ITMSetPropertyRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMSetPropertyResponse

@implementation ITMSetPropertyResponse

@dynamic hasStatus, status;

typedef struct ITMSetPropertyResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSetPropertyResponse_Status status;
} ITMSetPropertyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSetPropertyResponse_Status_EnumDescriptor,
        .number = ITMSetPropertyResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetPropertyResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetPropertyResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetPropertyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSetPropertyResponse_Status

GPBEnumDescriptor *ITMSetPropertyResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000UnrecognizedName\000InvalidValue\000Invalid"
        "Target\000Deferred\000Impossible\000";
    static const int32_t values[] = {
        ITMSetPropertyResponse_Status_Ok,
        ITMSetPropertyResponse_Status_UnrecognizedName,
        ITMSetPropertyResponse_Status_InvalidValue,
        ITMSetPropertyResponse_Status_InvalidTarget,
        ITMSetPropertyResponse_Status_Deferred,
        ITMSetPropertyResponse_Status_Impossible,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSetPropertyResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSetPropertyResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSetPropertyResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSetPropertyResponse_Status_Ok:
    case ITMSetPropertyResponse_Status_UnrecognizedName:
    case ITMSetPropertyResponse_Status_InvalidValue:
    case ITMSetPropertyResponse_Status_InvalidTarget:
    case ITMSetPropertyResponse_Status_Deferred:
    case ITMSetPropertyResponse_Status_Impossible:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMRegisterToolRequest

@implementation ITMRegisterToolRequest

@dynamic hasName, name;
@dynamic hasIdentifier, identifier;
@dynamic hasRevealIfAlreadyRegistered, revealIfAlreadyRegistered;
@dynamic hasToolType, toolType;
@dynamic hasURL, URL;

typedef struct ITMRegisterToolRequest__storage_ {
  uint32_t _has_storage_[1];
  ITMRegisterToolRequest_ToolType toolType;
  NSString *name;
  NSString *identifier;
  NSString *URL;
} ITMRegisterToolRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRegisterToolRequest_FieldNumber_Name,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMRegisterToolRequest__storage_, name),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "identifier",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRegisterToolRequest_FieldNumber_Identifier,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ITMRegisterToolRequest__storage_, identifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ITMRegisterToolRequest_ToolType_WebViewTool,
        .core.name = "toolType",
        .core.dataTypeSpecific.enumDescFunc = ITMRegisterToolRequest_ToolType_EnumDescriptor,
        .core.number = ITMRegisterToolRequest_FieldNumber_ToolType,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ITMRegisterToolRequest__storage_, toolType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "URL",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRegisterToolRequest_FieldNumber_URL,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ITMRegisterToolRequest__storage_, URL),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "revealIfAlreadyRegistered",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRegisterToolRequest_FieldNumber_RevealIfAlreadyRegistered,
        .core.hasIndex = 2,
        .core.offset = 3,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRegisterToolRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMRegisterToolRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMRegisterToolRequest_ToolType

GPBEnumDescriptor *ITMRegisterToolRequest_ToolType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "WebViewTool\000";
    static const int32_t values[] = {
        ITMRegisterToolRequest_ToolType_WebViewTool,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMRegisterToolRequest_ToolType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMRegisterToolRequest_ToolType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMRegisterToolRequest_ToolType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMRegisterToolRequest_ToolType_WebViewTool:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMRPCRegistrationRequest

@implementation ITMRPCRegistrationRequest

@dynamic roleSpecificAttributesOneOfCase;
@dynamic hasName, name;
@dynamic argumentsArray, argumentsArray_Count;
@dynamic defaultsArray, defaultsArray_Count;
@dynamic hasTimeout, timeout;
@dynamic hasRole, role;
@dynamic sessionTitleAttributes;
@dynamic statusBarComponentAttributes;
@dynamic hasDisplayName, displayName;

typedef struct ITMRPCRegistrationRequest__storage_ {
  uint32_t _has_storage_[2];
  float timeout;
  ITMRPCRegistrationRequest_Role role;
  NSString *name;
  NSMutableArray *argumentsArray;
  NSMutableArray *defaultsArray;
  NSString *displayName;
  ITMRPCRegistrationRequest_SessionTitleAttributes *sessionTitleAttributes;
  ITMRPCRegistrationRequest_StatusBarComponentAttributes *statusBarComponentAttributes;
} ITMRPCRegistrationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRPCRegistrationRequest_FieldNumber_Name,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest__storage_, name),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "argumentsArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ITMRPCRegistrationRequest_RPCArgumentSignature),
        .core.number = ITMRPCRegistrationRequest_FieldNumber_ArgumentsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest__storage_, argumentsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueFloat = 0,
        .core.name = "timeout",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRPCRegistrationRequest_FieldNumber_Timeout,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest__storage_, timeout),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeFloat,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "defaultsArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ITMRPCRegistrationRequest_RPCArgument),
        .core.number = ITMRPCRegistrationRequest_FieldNumber_DefaultsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest__storage_, defaultsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ITMRPCRegistrationRequest_Role_Generic,
        .core.name = "role",
        .core.dataTypeSpecific.enumDescFunc = ITMRPCRegistrationRequest_Role_EnumDescriptor,
        .core.number = ITMRPCRegistrationRequest_FieldNumber_Role,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest__storage_, role),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "displayName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRPCRegistrationRequest_FieldNumber_DisplayName,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest__storage_, displayName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "sessionTitleAttributes",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ITMRPCRegistrationRequest_SessionTitleAttributes),
        .core.number = ITMRPCRegistrationRequest_FieldNumber_SessionTitleAttributes,
        .core.hasIndex = -1,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest__storage_, sessionTitleAttributes),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "statusBarComponentAttributes",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ITMRPCRegistrationRequest_StatusBarComponentAttributes),
        .core.number = ITMRPCRegistrationRequest_FieldNumber_StatusBarComponentAttributes,
        .core.hasIndex = -1,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest__storage_, statusBarComponentAttributes),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRPCRegistrationRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMRPCRegistrationRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    static const char *oneofs[] = {
      "roleSpecificAttributes",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMRPCRegistrationRequest_ClearRoleSpecificAttributesOneOfCase(ITMRPCRegistrationRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Enum ITMRPCRegistrationRequest_Role

GPBEnumDescriptor *ITMRPCRegistrationRequest_Role_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Generic\000SessionTitle\000StatusBarComponent\000";
    static const int32_t values[] = {
        ITMRPCRegistrationRequest_Role_Generic,
        ITMRPCRegistrationRequest_Role_SessionTitle,
        ITMRPCRegistrationRequest_Role_StatusBarComponent,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMRPCRegistrationRequest_Role)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMRPCRegistrationRequest_Role_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMRPCRegistrationRequest_Role_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMRPCRegistrationRequest_Role_Generic:
    case ITMRPCRegistrationRequest_Role_SessionTitle:
    case ITMRPCRegistrationRequest_Role_StatusBarComponent:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMRPCRegistrationRequest_RPCArgumentSignature

@implementation ITMRPCRegistrationRequest_RPCArgumentSignature

@dynamic hasName, name;

typedef struct ITMRPCRegistrationRequest_RPCArgumentSignature__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} ITMRPCRegistrationRequest_RPCArgumentSignature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMRPCRegistrationRequest_RPCArgumentSignature_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_RPCArgumentSignature__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRPCRegistrationRequest_RPCArgumentSignature class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRPCRegistrationRequest_RPCArgumentSignature__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMRPCRegistrationRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMRPCRegistrationRequest_RPCArgument

@implementation ITMRPCRegistrationRequest_RPCArgument

@dynamic hasName, name;
@dynamic hasPath, path;

typedef struct ITMRPCRegistrationRequest_RPCArgument__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *path;
} ITMRPCRegistrationRequest_RPCArgument__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMRPCRegistrationRequest_RPCArgument_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_RPCArgument__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = ITMRPCRegistrationRequest_RPCArgument_FieldNumber_Path,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_RPCArgument__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRPCRegistrationRequest_RPCArgument class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRPCRegistrationRequest_RPCArgument__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMRPCRegistrationRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMRPCRegistrationRequest_SessionTitleAttributes

@implementation ITMRPCRegistrationRequest_SessionTitleAttributes

@dynamic hasDisplayName, displayName;

typedef struct ITMRPCRegistrationRequest_SessionTitleAttributes__storage_ {
  uint32_t _has_storage_[1];
  NSString *displayName;
} ITMRPCRegistrationRequest_SessionTitleAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = ITMRPCRegistrationRequest_SessionTitleAttributes_FieldNumber_DisplayName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_SessionTitleAttributes__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRPCRegistrationRequest_SessionTitleAttributes class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRPCRegistrationRequest_SessionTitleAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMRPCRegistrationRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMRPCRegistrationRequest_StatusBarComponentAttributes

@implementation ITMRPCRegistrationRequest_StatusBarComponentAttributes

@dynamic hasShortDescription, shortDescription;
@dynamic hasDetailedDescription, detailedDescription;
@dynamic knobsArray, knobsArray_Count;
@dynamic hasExemplar, exemplar;
@dynamic hasUpdateCadence, updateCadence;

typedef struct ITMRPCRegistrationRequest_StatusBarComponentAttributes__storage_ {
  uint32_t _has_storage_[1];
  float updateCadence;
  NSString *shortDescription;
  NSString *detailedDescription;
  NSMutableArray *knobsArray;
  NSString *exemplar;
} ITMRPCRegistrationRequest_StatusBarComponentAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shortDescription",
        .dataTypeSpecific.className = NULL,
        .number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_FieldNumber_ShortDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes__storage_, shortDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detailedDescription",
        .dataTypeSpecific.className = NULL,
        .number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_FieldNumber_DetailedDescription,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes__storage_, detailedDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "knobsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob),
        .number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_FieldNumber_KnobsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes__storage_, knobsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "exemplar",
        .dataTypeSpecific.className = NULL,
        .number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_FieldNumber_Exemplar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes__storage_, exemplar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "updateCadence",
        .dataTypeSpecific.className = NULL,
        .number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_FieldNumber_UpdateCadence,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes__storage_, updateCadence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRPCRegistrationRequest_StatusBarComponentAttributes class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRPCRegistrationRequest_StatusBarComponentAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMRPCRegistrationRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob

@implementation ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob

@dynamic hasName, name;
@dynamic hasType, type;
@dynamic hasPlaceholder, placeholder;
@dynamic hasJsonDefaultValue, jsonDefaultValue;
@dynamic hasKey, key;

typedef struct ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob__storage_ {
  uint32_t _has_storage_[1];
  ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type type;
  NSString *name;
  NSString *placeholder;
  NSString *jsonDefaultValue;
  NSString *key;
} ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_FieldNumber_Name,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob__storage_, name),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_Checkbox,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_EnumDescriptor,
        .core.number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_FieldNumber_Type,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "placeholder",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_FieldNumber_Placeholder,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob__storage_, placeholder),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "jsonDefaultValue",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_FieldNumber_JsonDefaultValue,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob__storage_, jsonDefaultValue),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "key",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_FieldNumber_Key,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob__storage_, key),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMRPCRegistrationRequest_StatusBarComponentAttributes)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type

GPBEnumDescriptor *ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Checkbox\000String\000PositiveFloatingPoint\000Co"
        "lor\000";
    static const int32_t values[] = {
        ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_Checkbox,
        ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_String,
        ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_PositiveFloatingPoint,
        ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_Color,
    };
    static const char *extraTextFormatInfo = "\004\000\010\000\001\006\000\002\025\000\003\005\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_Checkbox:
    case ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_String:
    case ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_PositiveFloatingPoint:
    case ITMRPCRegistrationRequest_StatusBarComponentAttributes_Knob_Type_Color:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMRegisterToolResponse

@implementation ITMRegisterToolResponse

@dynamic hasStatus, status;

typedef struct ITMRegisterToolResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMRegisterToolResponse_Status status;
} ITMRegisterToolResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMRegisterToolResponse_Status_EnumDescriptor,
        .number = ITMRegisterToolResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRegisterToolResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRegisterToolResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRegisterToolResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMRegisterToolResponse_Status

GPBEnumDescriptor *ITMRegisterToolResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000RequestMalformed\000PermissionDenied\000";
    static const int32_t values[] = {
        ITMRegisterToolResponse_Status_Ok,
        ITMRegisterToolResponse_Status_RequestMalformed,
        ITMRegisterToolResponse_Status_PermissionDenied,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMRegisterToolResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMRegisterToolResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMRegisterToolResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMRegisterToolResponse_Status_Ok:
    case ITMRegisterToolResponse_Status_RequestMalformed:
    case ITMRegisterToolResponse_Status_PermissionDenied:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMKeystrokePattern

@implementation ITMKeystrokePattern

@dynamic requiredModifiersArray, requiredModifiersArray_Count;
@dynamic forbiddenModifiersArray, forbiddenModifiersArray_Count;
@dynamic keycodesArray, keycodesArray_Count;
@dynamic charactersArray, charactersArray_Count;
@dynamic charactersIgnoringModifiersArray, charactersIgnoringModifiersArray_Count;

typedef struct ITMKeystrokePattern__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *requiredModifiersArray;
  GPBEnumArray *forbiddenModifiersArray;
  GPBInt32Array *keycodesArray;
  NSMutableArray *charactersArray;
  NSMutableArray *charactersIgnoringModifiersArray;
} ITMKeystrokePattern__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requiredModifiersArray",
        .dataTypeSpecific.enumDescFunc = ITMModifiers_EnumDescriptor,
        .number = ITMKeystrokePattern_FieldNumber_RequiredModifiersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMKeystrokePattern__storage_, requiredModifiersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "forbiddenModifiersArray",
        .dataTypeSpecific.enumDescFunc = ITMModifiers_EnumDescriptor,
        .number = ITMKeystrokePattern_FieldNumber_ForbiddenModifiersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMKeystrokePattern__storage_, forbiddenModifiersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "keycodesArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokePattern_FieldNumber_KeycodesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMKeystrokePattern__storage_, keycodesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charactersArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokePattern_FieldNumber_CharactersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMKeystrokePattern__storage_, charactersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charactersIgnoringModifiersArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokePattern_FieldNumber_CharactersIgnoringModifiersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMKeystrokePattern__storage_, charactersIgnoringModifiersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMKeystrokePattern class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMKeystrokePattern__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMKeystrokeMonitorRequest

@implementation ITMKeystrokeMonitorRequest

@dynamic patternsToIgnoreArray, patternsToIgnoreArray_Count;

typedef struct ITMKeystrokeMonitorRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *patternsToIgnoreArray;
} ITMKeystrokeMonitorRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "patternsToIgnoreArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMKeystrokePattern),
        .number = ITMKeystrokeMonitorRequest_FieldNumber_PatternsToIgnoreArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMKeystrokeMonitorRequest__storage_, patternsToIgnoreArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMKeystrokeMonitorRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMKeystrokeMonitorRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMNotificationRequest

@implementation ITMNotificationRequest

@dynamic argumentsOneOfCase;
@dynamic hasSession, session;
@dynamic hasSubscribe, subscribe;
@dynamic hasNotificationType, notificationType;
@dynamic rpcRegistrationRequest;
@dynamic keystrokeMonitorRequest;

typedef struct ITMNotificationRequest__storage_ {
  uint32_t _has_storage_[2];
  ITMNotificationType notificationType;
  NSString *session;
  ITMRPCRegistrationRequest *rpcRegistrationRequest;
  ITMKeystrokeMonitorRequest *keystrokeMonitorRequest;
} ITMNotificationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "session",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMNotificationRequest_FieldNumber_Session,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMNotificationRequest__storage_, session),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "subscribe",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMNotificationRequest_FieldNumber_Subscribe,
        .core.hasIndex = 1,
        .core.offset = 2,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueEnum = ITMNotificationType_NotifyOnKeystroke,
        .core.name = "notificationType",
        .core.dataTypeSpecific.enumDescFunc = ITMNotificationType_EnumDescriptor,
        .core.number = ITMNotificationRequest_FieldNumber_NotificationType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ITMNotificationRequest__storage_, notificationType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rpcRegistrationRequest",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ITMRPCRegistrationRequest),
        .core.number = ITMNotificationRequest_FieldNumber_RpcRegistrationRequest,
        .core.hasIndex = -1,
        .core.offset = (uint32_t)offsetof(ITMNotificationRequest__storage_, rpcRegistrationRequest),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "keystrokeMonitorRequest",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ITMKeystrokeMonitorRequest),
        .core.number = ITMNotificationRequest_FieldNumber_KeystrokeMonitorRequest,
        .core.hasIndex = -1,
        .core.offset = (uint32_t)offsetof(ITMNotificationRequest__storage_, keystrokeMonitorRequest),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMNotificationRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMNotificationRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    static const char *oneofs[] = {
      "arguments",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMNotificationRequest_ClearArgumentsOneOfCase(ITMNotificationRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMNotificationResponse

@implementation ITMNotificationResponse

@dynamic hasStatus, status;

typedef struct ITMNotificationResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMNotificationResponse_Status status;
} ITMNotificationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMNotificationResponse_Status_EnumDescriptor,
        .number = ITMNotificationResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMNotificationResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMNotificationResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMNotificationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMNotificationResponse_Status

GPBEnumDescriptor *ITMNotificationResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000RequestMalformed\000NotS"
        "ubscribed\000AlreadySubscribed\000DuplicateSer"
        "verOriginatedRpc\000";
    static const int32_t values[] = {
        ITMNotificationResponse_Status_Ok,
        ITMNotificationResponse_Status_SessionNotFound,
        ITMNotificationResponse_Status_RequestMalformed,
        ITMNotificationResponse_Status_NotSubscribed,
        ITMNotificationResponse_Status_AlreadySubscribed,
        ITMNotificationResponse_Status_DuplicateServerOriginatedRpc,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMNotificationResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMNotificationResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMNotificationResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMNotificationResponse_Status_Ok:
    case ITMNotificationResponse_Status_SessionNotFound:
    case ITMNotificationResponse_Status_RequestMalformed:
    case ITMNotificationResponse_Status_NotSubscribed:
    case ITMNotificationResponse_Status_AlreadySubscribed:
    case ITMNotificationResponse_Status_DuplicateServerOriginatedRpc:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMNotification

@implementation ITMNotification

@dynamic hasKeystrokeNotification, keystrokeNotification;
@dynamic hasScreenUpdateNotification, screenUpdateNotification;
@dynamic hasPromptNotification, promptNotification;
@dynamic hasLocationChangeNotification, locationChangeNotification;
@dynamic hasCustomEscapeSequenceNotification, customEscapeSequenceNotification;
@dynamic hasNewSessionNotification, newSessionNotification;
@dynamic hasTerminateSessionNotification, terminateSessionNotification;
@dynamic hasLayoutChangedNotification, layoutChangedNotification;
@dynamic hasFocusChangedNotification, focusChangedNotification;
@dynamic hasServerOriginatedRpcNotification, serverOriginatedRpcNotification;
@dynamic hasBroadcastDomainsChanged, broadcastDomainsChanged;

typedef struct ITMNotification__storage_ {
  uint32_t _has_storage_[1];
  ITMKeystrokeNotification *keystrokeNotification;
  ITMScreenUpdateNotification *screenUpdateNotification;
  ITMPromptNotification *promptNotification;
  ITMLocationChangeNotification *locationChangeNotification;
  ITMCustomEscapeSequenceNotification *customEscapeSequenceNotification;
  ITMNewSessionNotification *newSessionNotification;
  ITMTerminateSessionNotification *terminateSessionNotification;
  ITMLayoutChangedNotification *layoutChangedNotification;
  ITMFocusChangedNotification *focusChangedNotification;
  ITMServerOriginatedRPCNotification *serverOriginatedRpcNotification;
  ITMBroadcastDomainsChangedNotification *broadcastDomainsChanged;
} ITMNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keystrokeNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMKeystrokeNotification),
        .number = ITMNotification_FieldNumber_KeystrokeNotification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, keystrokeNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "screenUpdateNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMScreenUpdateNotification),
        .number = ITMNotification_FieldNumber_ScreenUpdateNotification,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, screenUpdateNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "promptNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMPromptNotification),
        .number = ITMNotification_FieldNumber_PromptNotification,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, promptNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "locationChangeNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMLocationChangeNotification),
        .number = ITMNotification_FieldNumber_LocationChangeNotification,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, locationChangeNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customEscapeSequenceNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCustomEscapeSequenceNotification),
        .number = ITMNotification_FieldNumber_CustomEscapeSequenceNotification,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, customEscapeSequenceNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newSessionNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMNewSessionNotification),
        .number = ITMNotification_FieldNumber_NewSessionNotification,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, newSessionNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "terminateSessionNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMTerminateSessionNotification),
        .number = ITMNotification_FieldNumber_TerminateSessionNotification,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, terminateSessionNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "layoutChangedNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMLayoutChangedNotification),
        .number = ITMNotification_FieldNumber_LayoutChangedNotification,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, layoutChangedNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "focusChangedNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusChangedNotification),
        .number = ITMNotification_FieldNumber_FocusChangedNotification,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, focusChangedNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverOriginatedRpcNotification",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMServerOriginatedRPCNotification),
        .number = ITMNotification_FieldNumber_ServerOriginatedRpcNotification,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, serverOriginatedRpcNotification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "broadcastDomainsChanged",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMBroadcastDomainsChangedNotification),
        .number = ITMNotification_FieldNumber_BroadcastDomainsChanged,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ITMNotification__storage_, broadcastDomainsChanged),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMBroadcastDomainsChangedNotification

@implementation ITMBroadcastDomainsChangedNotification

@dynamic broadcastDomainsArray, broadcastDomainsArray_Count;

typedef struct ITMBroadcastDomainsChangedNotification__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *broadcastDomainsArray;
} ITMBroadcastDomainsChangedNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "broadcastDomainsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMBroadcastDomain),
        .number = ITMBroadcastDomainsChangedNotification_FieldNumber_BroadcastDomainsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMBroadcastDomainsChangedNotification__storage_, broadcastDomainsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMBroadcastDomainsChangedNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMBroadcastDomainsChangedNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMServerOriginatedRPC

@implementation ITMServerOriginatedRPC

@dynamic hasName, name;
@dynamic argumentsArray, argumentsArray_Count;

typedef struct ITMServerOriginatedRPC__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableArray *argumentsArray;
} ITMServerOriginatedRPC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedRPC_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMServerOriginatedRPC__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argumentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMServerOriginatedRPC_RPCArgument),
        .number = ITMServerOriginatedRPC_FieldNumber_ArgumentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMServerOriginatedRPC__storage_, argumentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMServerOriginatedRPC class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMServerOriginatedRPC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMServerOriginatedRPC_RPCArgument

@implementation ITMServerOriginatedRPC_RPCArgument

@dynamic hasName, name;
@dynamic hasJsonValue, jsonValue;

typedef struct ITMServerOriginatedRPC_RPCArgument__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *jsonValue;
} ITMServerOriginatedRPC_RPCArgument__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedRPC_RPCArgument_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMServerOriginatedRPC_RPCArgument__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedRPC_RPCArgument_FieldNumber_JsonValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedRPC_RPCArgument__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMServerOriginatedRPC_RPCArgument class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMServerOriginatedRPC_RPCArgument__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMServerOriginatedRPC)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMServerOriginatedRPCNotification

@implementation ITMServerOriginatedRPCNotification

@dynamic hasRequestId, requestId;
@dynamic hasRpc, rpc;

typedef struct ITMServerOriginatedRPCNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *requestId;
  ITMServerOriginatedRPC *rpc;
} ITMServerOriginatedRPCNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = ITMServerOriginatedRPCNotification_FieldNumber_RequestId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMServerOriginatedRPCNotification__storage_, requestId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rpc",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMServerOriginatedRPC),
        .number = ITMServerOriginatedRPCNotification_FieldNumber_Rpc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMServerOriginatedRPCNotification__storage_, rpc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMServerOriginatedRPCNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMServerOriginatedRPCNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMKeystrokeNotification

@implementation ITMKeystrokeNotification

@dynamic hasCharacters, characters;
@dynamic hasCharactersIgnoringModifiers, charactersIgnoringModifiers;
@dynamic modifiersArray, modifiersArray_Count;
@dynamic hasKeyCode, keyCode;
@dynamic hasSession, session;

typedef struct ITMKeystrokeNotification__storage_ {
  uint32_t _has_storage_[1];
  int32_t keyCode;
  NSString *characters;
  NSString *charactersIgnoringModifiers;
  GPBEnumArray *modifiersArray;
  NSString *session;
} ITMKeystrokeNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "characters",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokeNotification_FieldNumber_Characters,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, characters),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charactersIgnoringModifiers",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokeNotification_FieldNumber_CharactersIgnoringModifiers,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, charactersIgnoringModifiers),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modifiersArray",
        .dataTypeSpecific.enumDescFunc = ITMModifiers_EnumDescriptor,
        .number = ITMKeystrokeNotification_FieldNumber_ModifiersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, modifiersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "keyCode",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokeNotification_FieldNumber_KeyCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, keyCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMKeystrokeNotification_FieldNumber_Session,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMKeystrokeNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMKeystrokeNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMKeystrokeNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\033\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMScreenUpdateNotification

@implementation ITMScreenUpdateNotification

@dynamic hasSession, session;

typedef struct ITMScreenUpdateNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
} ITMScreenUpdateNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMScreenUpdateNotification_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMScreenUpdateNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMScreenUpdateNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMScreenUpdateNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMPromptNotification

@implementation ITMPromptNotification

@dynamic hasSession, session;

typedef struct ITMPromptNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
} ITMPromptNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMPromptNotification_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMPromptNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMPromptNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMPromptNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMLocationChangeNotification

@implementation ITMLocationChangeNotification

@dynamic hasHostName, hostName;
@dynamic hasUserName, userName;
@dynamic hasDirectory, directory;
@dynamic hasSession, session;

typedef struct ITMLocationChangeNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *hostName;
  NSString *userName;
  NSString *directory;
  NSString *session;
} ITMLocationChangeNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostName",
        .dataTypeSpecific.className = NULL,
        .number = ITMLocationChangeNotification_FieldNumber_HostName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMLocationChangeNotification__storage_, hostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ITMLocationChangeNotification_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMLocationChangeNotification__storage_, userName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "directory",
        .dataTypeSpecific.className = NULL,
        .number = ITMLocationChangeNotification_FieldNumber_Directory,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMLocationChangeNotification__storage_, directory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMLocationChangeNotification_FieldNumber_Session,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMLocationChangeNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMLocationChangeNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMLocationChangeNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCustomEscapeSequenceNotification

@implementation ITMCustomEscapeSequenceNotification

@dynamic hasSession, session;
@dynamic hasSenderIdentity, senderIdentity;
@dynamic hasPayload, payload;

typedef struct ITMCustomEscapeSequenceNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  NSString *senderIdentity;
  NSString *payload;
} ITMCustomEscapeSequenceNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMCustomEscapeSequenceNotification_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCustomEscapeSequenceNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderIdentity",
        .dataTypeSpecific.className = NULL,
        .number = ITMCustomEscapeSequenceNotification_FieldNumber_SenderIdentity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCustomEscapeSequenceNotification__storage_, senderIdentity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = NULL,
        .number = ITMCustomEscapeSequenceNotification_FieldNumber_Payload,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMCustomEscapeSequenceNotification__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCustomEscapeSequenceNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCustomEscapeSequenceNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMNewSessionNotification

@implementation ITMNewSessionNotification

@dynamic hasUniqueIdentifier, uniqueIdentifier;

typedef struct ITMNewSessionNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *uniqueIdentifier;
} ITMNewSessionNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uniqueIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = ITMNewSessionNotification_FieldNumber_UniqueIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMNewSessionNotification__storage_, uniqueIdentifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMNewSessionNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMNewSessionNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMFocusChangedNotification

@implementation ITMFocusChangedNotification

@dynamic eventOneOfCase;
@dynamic applicationActive;
@dynamic window;
@dynamic selectedTab;
@dynamic session;

typedef struct ITMFocusChangedNotification__storage_ {
  uint32_t _has_storage_[2];
  ITMFocusChangedNotification_Window *window;
  NSString *selectedTab;
  NSString *session;
} ITMFocusChangedNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applicationActive",
        .dataTypeSpecific.className = NULL,
        .number = ITMFocusChangedNotification_FieldNumber_ApplicationActive,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "window",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFocusChangedNotification_Window),
        .number = ITMFocusChangedNotification_FieldNumber_Window,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification__storage_, window),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "selectedTab",
        .dataTypeSpecific.className = NULL,
        .number = ITMFocusChangedNotification_FieldNumber_SelectedTab,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification__storage_, selectedTab),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMFocusChangedNotification_FieldNumber_Session,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFocusChangedNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMFocusChangedNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "event",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMFocusChangedNotification_ClearEventOneOfCase(ITMFocusChangedNotification *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMFocusChangedNotification_Window

@implementation ITMFocusChangedNotification_Window

@dynamic hasWindowStatus, windowStatus;
@dynamic hasWindowId, windowId;

typedef struct ITMFocusChangedNotification_Window__storage_ {
  uint32_t _has_storage_[1];
  ITMFocusChangedNotification_Window_WindowStatus windowStatus;
  NSString *windowId;
} ITMFocusChangedNotification_Window__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowStatus",
        .dataTypeSpecific.enumDescFunc = ITMFocusChangedNotification_Window_WindowStatus_EnumDescriptor,
        .number = ITMFocusChangedNotification_Window_FieldNumber_WindowStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification_Window__storage_, windowStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMFocusChangedNotification_Window_FieldNumber_WindowId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMFocusChangedNotification_Window__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFocusChangedNotification_Window class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMFocusChangedNotification_Window__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMFocusChangedNotification)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMFocusChangedNotification_Window_WindowStatus

GPBEnumDescriptor *ITMFocusChangedNotification_Window_WindowStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TerminalWindowBecameKey\000TerminalWindowIs"
        "Current\000TerminalWindowResignedKey\000";
    static const int32_t values[] = {
        ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowBecameKey,
        ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowIsCurrent,
        ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowResignedKey,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMFocusChangedNotification_Window_WindowStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMFocusChangedNotification_Window_WindowStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMFocusChangedNotification_Window_WindowStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowBecameKey:
    case ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowIsCurrent:
    case ITMFocusChangedNotification_Window_WindowStatus_TerminalWindowResignedKey:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMTerminateSessionNotification

@implementation ITMTerminateSessionNotification

@dynamic hasUniqueIdentifier, uniqueIdentifier;

typedef struct ITMTerminateSessionNotification__storage_ {
  uint32_t _has_storage_[1];
  NSString *uniqueIdentifier;
} ITMTerminateSessionNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uniqueIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = ITMTerminateSessionNotification_FieldNumber_UniqueIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMTerminateSessionNotification__storage_, uniqueIdentifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTerminateSessionNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTerminateSessionNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMLayoutChangedNotification

@implementation ITMLayoutChangedNotification

@dynamic hasListSessionsResponse, listSessionsResponse;

typedef struct ITMLayoutChangedNotification__storage_ {
  uint32_t _has_storage_[1];
  ITMListSessionsResponse *listSessionsResponse;
} ITMLayoutChangedNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listSessionsResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse),
        .number = ITMLayoutChangedNotification_FieldNumber_ListSessionsResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMLayoutChangedNotification__storage_, listSessionsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMLayoutChangedNotification class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMLayoutChangedNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetBufferRequest

@implementation ITMGetBufferRequest

@dynamic hasSession, session;
@dynamic hasLineRange, lineRange;

typedef struct ITMGetBufferRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  ITMLineRange *lineRange;
} ITMGetBufferRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetBufferRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetBufferRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lineRange",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMLineRange),
        .number = ITMGetBufferRequest_FieldNumber_LineRange,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMGetBufferRequest__storage_, lineRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetBufferRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetBufferRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetBufferResponse

@implementation ITMGetBufferResponse

@dynamic hasStatus, status;
@dynamic hasRange, range;
@dynamic contentsArray, contentsArray_Count;
@dynamic hasCursor, cursor;
@dynamic hasNumLinesAboveScreen, numLinesAboveScreen;

typedef struct ITMGetBufferResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMGetBufferResponse_Status status;
  ITMRange *range;
  NSMutableArray *contentsArray;
  ITMCoord *cursor;
  int64_t numLinesAboveScreen;
} ITMGetBufferResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMGetBufferResponse_Status_EnumDescriptor,
        .number = ITMGetBufferResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "range",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMRange),
        .number = ITMGetBufferResponse_FieldNumber_Range,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, range),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMLineContents),
        .number = ITMGetBufferResponse_FieldNumber_ContentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, contentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cursor",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoord),
        .number = ITMGetBufferResponse_FieldNumber_Cursor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, cursor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "numLinesAboveScreen",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetBufferResponse_FieldNumber_NumLinesAboveScreen,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMGetBufferResponse__storage_, numLinesAboveScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetBufferResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetBufferResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMGetBufferResponse_Status

GPBEnumDescriptor *ITMGetBufferResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000InvalidLineRange\000Requ"
        "estMalformed\000";
    static const int32_t values[] = {
        ITMGetBufferResponse_Status_Ok,
        ITMGetBufferResponse_Status_SessionNotFound,
        ITMGetBufferResponse_Status_InvalidLineRange,
        ITMGetBufferResponse_Status_RequestMalformed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMGetBufferResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMGetBufferResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMGetBufferResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMGetBufferResponse_Status_Ok:
    case ITMGetBufferResponse_Status_SessionNotFound:
    case ITMGetBufferResponse_Status_InvalidLineRange:
    case ITMGetBufferResponse_Status_RequestMalformed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMGetPromptRequest

@implementation ITMGetPromptRequest

@dynamic hasSession, session;

typedef struct ITMGetPromptRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
} ITMGetPromptRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPromptRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetPromptRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetPromptRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetPromptRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetPromptResponse

@implementation ITMGetPromptResponse

@dynamic hasStatus, status;
@dynamic hasPromptRange, promptRange;
@dynamic hasCommandRange, commandRange;
@dynamic hasOutputRange, outputRange;
@dynamic hasWorkingDirectory, workingDirectory;
@dynamic hasCommand, command;

typedef struct ITMGetPromptResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMGetPromptResponse_Status status;
  ITMCoordRange *promptRange;
  ITMCoordRange *commandRange;
  ITMCoordRange *outputRange;
  NSString *workingDirectory;
  NSString *command;
} ITMGetPromptResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMGetPromptResponse_Status_EnumDescriptor,
        .number = ITMGetPromptResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "promptRange",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoordRange),
        .number = ITMGetPromptResponse_FieldNumber_PromptRange,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, promptRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commandRange",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoordRange),
        .number = ITMGetPromptResponse_FieldNumber_CommandRange,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, commandRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputRange",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoordRange),
        .number = ITMGetPromptResponse_FieldNumber_OutputRange,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, outputRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "workingDirectory",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPromptResponse_FieldNumber_WorkingDirectory,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, workingDirectory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "command",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetPromptResponse_FieldNumber_Command,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ITMGetPromptResponse__storage_, command),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetPromptResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetPromptResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMGetPromptResponse_Status

GPBEnumDescriptor *ITMGetPromptResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000RequestMalformed\000Prom"
        "ptUnavailable\000";
    static const int32_t values[] = {
        ITMGetPromptResponse_Status_Ok,
        ITMGetPromptResponse_Status_SessionNotFound,
        ITMGetPromptResponse_Status_RequestMalformed,
        ITMGetPromptResponse_Status_PromptUnavailable,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMGetPromptResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMGetPromptResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMGetPromptResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMGetPromptResponse_Status_Ok:
    case ITMGetPromptResponse_Status_SessionNotFound:
    case ITMGetPromptResponse_Status_RequestMalformed:
    case ITMGetPromptResponse_Status_PromptUnavailable:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMGetProfilePropertyRequest

@implementation ITMGetProfilePropertyRequest

@dynamic hasSession, session;
@dynamic keysArray, keysArray_Count;

typedef struct ITMGetProfilePropertyRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  NSMutableArray *keysArray;
} ITMGetProfilePropertyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetProfilePropertyRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keysArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMGetProfilePropertyRequest_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyRequest__storage_, keysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetProfilePropertyRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetProfilePropertyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMProfileProperty

@implementation ITMProfileProperty

@dynamic hasKey, key;
@dynamic hasJsonValue, jsonValue;

typedef struct ITMProfileProperty__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *jsonValue;
} ITMProfileProperty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ITMProfileProperty_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMProfileProperty__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMProfileProperty_FieldNumber_JsonValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMProfileProperty__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMProfileProperty class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMProfileProperty__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMGetProfilePropertyResponse

@implementation ITMGetProfilePropertyResponse

@dynamic hasStatus, status;
@dynamic propertiesArray, propertiesArray_Count;

typedef struct ITMGetProfilePropertyResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMGetProfilePropertyResponse_Status status;
  NSMutableArray *propertiesArray;
} ITMGetProfilePropertyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMGetProfilePropertyResponse_Status_EnumDescriptor,
        .number = ITMGetProfilePropertyResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "propertiesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMProfileProperty),
        .number = ITMGetProfilePropertyResponse_FieldNumber_PropertiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMGetProfilePropertyResponse__storage_, propertiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMGetProfilePropertyResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMGetProfilePropertyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMGetProfilePropertyResponse_Status

GPBEnumDescriptor *ITMGetProfilePropertyResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000RequestMalformed\000Erro"
        "r\000";
    static const int32_t values[] = {
        ITMGetProfilePropertyResponse_Status_Ok,
        ITMGetProfilePropertyResponse_Status_SessionNotFound,
        ITMGetProfilePropertyResponse_Status_RequestMalformed,
        ITMGetProfilePropertyResponse_Status_Error,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMGetProfilePropertyResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMGetProfilePropertyResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMGetProfilePropertyResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMGetProfilePropertyResponse_Status_Ok:
    case ITMGetProfilePropertyResponse_Status_SessionNotFound:
    case ITMGetProfilePropertyResponse_Status_RequestMalformed:
    case ITMGetProfilePropertyResponse_Status_Error:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSetProfilePropertyRequest

@implementation ITMSetProfilePropertyRequest

@dynamic targetOneOfCase;
@dynamic session;
@dynamic guidList;
@dynamic hasKey, key;
@dynamic hasJsonValue, jsonValue;

typedef struct ITMSetProfilePropertyRequest__storage_ {
  uint32_t _has_storage_[2];
  NSString *session;
  ITMSetProfilePropertyRequest_GuidList *guidList;
  NSString *key;
  NSString *jsonValue;
} ITMSetProfilePropertyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetProfilePropertyRequest_FieldNumber_Session,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "guidList",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSetProfilePropertyRequest_GuidList),
        .number = ITMSetProfilePropertyRequest_FieldNumber_GuidList,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyRequest__storage_, guidList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetProfilePropertyRequest_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonValue",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetProfilePropertyRequest_FieldNumber_JsonValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyRequest__storage_, jsonValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetProfilePropertyRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetProfilePropertyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "target",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMSetProfilePropertyRequest_ClearTargetOneOfCase(ITMSetProfilePropertyRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMSetProfilePropertyRequest_GuidList

@implementation ITMSetProfilePropertyRequest_GuidList

@dynamic guidsArray, guidsArray_Count;

typedef struct ITMSetProfilePropertyRequest_GuidList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *guidsArray;
} ITMSetProfilePropertyRequest_GuidList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "guidsArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMSetProfilePropertyRequest_GuidList_FieldNumber_GuidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyRequest_GuidList__storage_, guidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetProfilePropertyRequest_GuidList class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetProfilePropertyRequest_GuidList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMSetProfilePropertyRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSetProfilePropertyResponse

@implementation ITMSetProfilePropertyResponse

@dynamic hasStatus, status;

typedef struct ITMSetProfilePropertyResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSetProfilePropertyResponse_Status status;
} ITMSetProfilePropertyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSetProfilePropertyResponse_Status_EnumDescriptor,
        .number = ITMSetProfilePropertyResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSetProfilePropertyResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSetProfilePropertyResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSetProfilePropertyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSetProfilePropertyResponse_Status

GPBEnumDescriptor *ITMSetProfilePropertyResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000RequestMalformed\000BadG"
        "uid\000";
    static const int32_t values[] = {
        ITMSetProfilePropertyResponse_Status_Ok,
        ITMSetProfilePropertyResponse_Status_SessionNotFound,
        ITMSetProfilePropertyResponse_Status_RequestMalformed,
        ITMSetProfilePropertyResponse_Status_BadGuid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSetProfilePropertyResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSetProfilePropertyResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSetProfilePropertyResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSetProfilePropertyResponse_Status_Ok:
    case ITMSetProfilePropertyResponse_Status_SessionNotFound:
    case ITMSetProfilePropertyResponse_Status_RequestMalformed:
    case ITMSetProfilePropertyResponse_Status_BadGuid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMTransactionRequest

@implementation ITMTransactionRequest

@dynamic hasBegin, begin;

typedef struct ITMTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
} ITMTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "begin",
        .dataTypeSpecific.className = NULL,
        .number = ITMTransactionRequest_FieldNumber_Begin,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTransactionRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTransactionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMTransactionResponse

@implementation ITMTransactionResponse

@dynamic hasStatus, status;

typedef struct ITMTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMTransactionResponse_Status status;
} ITMTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMTransactionResponse_Status_EnumDescriptor,
        .number = ITMTransactionResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMTransactionResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMTransactionResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMTransactionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMTransactionResponse_Status

GPBEnumDescriptor *ITMTransactionResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000NoTransaction\000AlreadyInTransaction\000";
    static const int32_t values[] = {
        ITMTransactionResponse_Status_Ok,
        ITMTransactionResponse_Status_NoTransaction,
        ITMTransactionResponse_Status_AlreadyInTransaction,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMTransactionResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMTransactionResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMTransactionResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMTransactionResponse_Status_Ok:
    case ITMTransactionResponse_Status_NoTransaction:
    case ITMTransactionResponse_Status_AlreadyInTransaction:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMLineRange

@implementation ITMLineRange

@dynamic hasScreenContentsOnly, screenContentsOnly;
@dynamic hasTrailingLines, trailingLines;

typedef struct ITMLineRange__storage_ {
  uint32_t _has_storage_[1];
  int32_t trailingLines;
} ITMLineRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "screenContentsOnly",
        .dataTypeSpecific.className = NULL,
        .number = ITMLineRange_FieldNumber_ScreenContentsOnly,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "trailingLines",
        .dataTypeSpecific.className = NULL,
        .number = ITMLineRange_FieldNumber_TrailingLines,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMLineRange__storage_, trailingLines),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMLineRange class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMLineRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMRange

@implementation ITMRange

@dynamic hasLocation, location;
@dynamic hasLength, length;

typedef struct ITMRange__storage_ {
  uint32_t _has_storage_[1];
  int64_t location;
  int64_t length;
} ITMRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "location",
        .dataTypeSpecific.className = NULL,
        .number = ITMRange_FieldNumber_Location,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMRange__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "length",
        .dataTypeSpecific.className = NULL,
        .number = ITMRange_FieldNumber_Length,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMRange__storage_, length),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMRange class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCoordRange

@implementation ITMCoordRange

@dynamic hasStart, start;
@dynamic hasEnd, end;

typedef struct ITMCoordRange__storage_ {
  uint32_t _has_storage_[1];
  ITMCoord *start;
  ITMCoord *end;
} ITMCoordRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoord),
        .number = ITMCoordRange_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCoordRange__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMCoord),
        .number = ITMCoordRange_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCoordRange__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCoordRange class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCoordRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCoord

@implementation ITMCoord

@dynamic hasX, x;
@dynamic hasY, y;

typedef struct ITMCoord__storage_ {
  uint32_t _has_storage_[1];
  int32_t x;
  int64_t y;
} ITMCoord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = ITMCoord_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCoord__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = ITMCoord_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCoord__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCoord class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCoord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMLineContents

@implementation ITMLineContents

@dynamic hasText, text;
@dynamic codePointsPerCellArray, codePointsPerCellArray_Count;
@dynamic hasContinuation, continuation;

typedef struct ITMLineContents__storage_ {
  uint32_t _has_storage_[1];
  ITMLineContents_Continuation continuation;
  NSString *text;
  NSMutableArray *codePointsPerCellArray;
} ITMLineContents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "text",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMLineContents_FieldNumber_Text,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMLineContents__storage_, text),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "codePointsPerCellArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ITMCodePointsPerCell),
        .core.number = ITMLineContents_FieldNumber_CodePointsPerCellArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ITMLineContents__storage_, codePointsPerCellArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ITMLineContents_Continuation_ContinuationHardEol,
        .core.name = "continuation",
        .core.dataTypeSpecific.enumDescFunc = ITMLineContents_Continuation_EnumDescriptor,
        .core.number = ITMLineContents_FieldNumber_Continuation,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ITMLineContents__storage_, continuation),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMLineContents class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMLineContents__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMLineContents_Continuation

GPBEnumDescriptor *ITMLineContents_Continuation_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ContinuationHardEol\000ContinuationSoftEol\000";
    static const int32_t values[] = {
        ITMLineContents_Continuation_ContinuationHardEol,
        ITMLineContents_Continuation_ContinuationSoftEol,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMLineContents_Continuation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMLineContents_Continuation_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMLineContents_Continuation_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMLineContents_Continuation_ContinuationHardEol:
    case ITMLineContents_Continuation_ContinuationSoftEol:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMCodePointsPerCell

@implementation ITMCodePointsPerCell

@dynamic hasNumCodePoints, numCodePoints;
@dynamic hasRepeats, repeats;

typedef struct ITMCodePointsPerCell__storage_ {
  uint32_t _has_storage_[1];
  int32_t numCodePoints;
  int32_t repeats;
} ITMCodePointsPerCell__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueInt32 = 1,
        .core.name = "numCodePoints",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMCodePointsPerCell_FieldNumber_NumCodePoints,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ITMCodePointsPerCell__storage_, numCodePoints),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "repeats",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ITMCodePointsPerCell_FieldNumber_Repeats,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ITMCodePointsPerCell__storage_, repeats),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCodePointsPerCell class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ITMCodePointsPerCell__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListSessionsRequest

@implementation ITMListSessionsRequest


typedef struct ITMListSessionsRequest__storage_ {
  uint32_t _has_storage_[1];
} ITMListSessionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ITMListSessionsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSendTextRequest

@implementation ITMSendTextRequest

@dynamic hasSession, session;
@dynamic hasText, text;
@dynamic hasSuppressBroadcast, suppressBroadcast;

typedef struct ITMSendTextRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  NSString *text;
} ITMSendTextRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMSendTextRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSendTextRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = ITMSendTextRequest_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSendTextRequest__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "suppressBroadcast",
        .dataTypeSpecific.className = NULL,
        .number = ITMSendTextRequest_FieldNumber_SuppressBroadcast,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSendTextRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSendTextRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSendTextResponse

@implementation ITMSendTextResponse

@dynamic hasStatus, status;

typedef struct ITMSendTextResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSendTextResponse_Status status;
} ITMSendTextResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSendTextResponse_Status_EnumDescriptor,
        .number = ITMSendTextResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSendTextResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSendTextResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSendTextResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSendTextResponse_Status

GPBEnumDescriptor *ITMSendTextResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000";
    static const int32_t values[] = {
        ITMSendTextResponse_Status_Ok,
        ITMSendTextResponse_Status_SessionNotFound,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSendTextResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSendTextResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSendTextResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSendTextResponse_Status_Ok:
    case ITMSendTextResponse_Status_SessionNotFound:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSize

@implementation ITMSize

@dynamic hasWidth, width;
@dynamic hasHeight, height;

typedef struct ITMSize__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
} ITMSize__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = ITMSize_FieldNumber_Width,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSize__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = ITMSize_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSize__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSize class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSize__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMPoint

@implementation ITMPoint

@dynamic hasX, x;
@dynamic hasY, y;

typedef struct ITMPoint__storage_ {
  uint32_t _has_storage_[1];
  int32_t x;
  int32_t y;
} ITMPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = ITMPoint_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMPoint__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = ITMPoint_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMPoint__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMPoint class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMFrame

@implementation ITMFrame

@dynamic hasOrigin, origin;
@dynamic hasSize, size;

typedef struct ITMFrame__storage_ {
  uint32_t _has_storage_[1];
  ITMPoint *origin;
  ITMSize *size;
} ITMFrame__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "origin",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMPoint),
        .number = ITMFrame_FieldNumber_Origin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMFrame__storage_, origin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSize),
        .number = ITMFrame_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMFrame__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMFrame class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMFrame__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSessionSummary

@implementation ITMSessionSummary

@dynamic hasUniqueIdentifier, uniqueIdentifier;
@dynamic hasFrame, frame;
@dynamic hasGridSize, gridSize;
@dynamic hasTitle, title;

typedef struct ITMSessionSummary__storage_ {
  uint32_t _has_storage_[1];
  NSString *uniqueIdentifier;
  ITMFrame *frame;
  ITMSize *gridSize;
  NSString *title;
} ITMSessionSummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uniqueIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = ITMSessionSummary_FieldNumber_UniqueIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSessionSummary__storage_, uniqueIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "frame",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFrame),
        .number = ITMSessionSummary_FieldNumber_Frame,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSessionSummary__storage_, frame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gridSize",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSize),
        .number = ITMSessionSummary_FieldNumber_GridSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMSessionSummary__storage_, gridSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ITMSessionSummary_FieldNumber_Title,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMSessionSummary__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSessionSummary class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSessionSummary__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSplitTreeNode

@implementation ITMSplitTreeNode

@dynamic hasVertical, vertical;
@dynamic linksArray, linksArray_Count;

typedef struct ITMSplitTreeNode__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *linksArray;
} ITMSplitTreeNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vertical",
        .dataTypeSpecific.className = NULL,
        .number = ITMSplitTreeNode_FieldNumber_Vertical,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "linksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSplitTreeNode_SplitTreeLink),
        .number = ITMSplitTreeNode_FieldNumber_LinksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMSplitTreeNode__storage_, linksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSplitTreeNode class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSplitTreeNode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMSplitTreeNode_SplitTreeLink

@implementation ITMSplitTreeNode_SplitTreeLink

@dynamic childOneOfCase;
@dynamic session;
@dynamic node;

typedef struct ITMSplitTreeNode_SplitTreeLink__storage_ {
  uint32_t _has_storage_[2];
  ITMSessionSummary *session;
  ITMSplitTreeNode *node;
} ITMSplitTreeNode_SplitTreeLink__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSessionSummary),
        .number = ITMSplitTreeNode_SplitTreeLink_FieldNumber_Session,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMSplitTreeNode_SplitTreeLink__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSplitTreeNode),
        .number = ITMSplitTreeNode_SplitTreeLink_FieldNumber_Node,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ITMSplitTreeNode_SplitTreeLink__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSplitTreeNode_SplitTreeLink class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSplitTreeNode_SplitTreeLink__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "child",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMSplitTreeNode)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ITMSplitTreeNode_SplitTreeLink_ClearChildOneOfCase(ITMSplitTreeNode_SplitTreeLink *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ITMListSessionsResponse

@implementation ITMListSessionsResponse

@dynamic windowsArray, windowsArray_Count;
@dynamic buriedSessionsArray, buriedSessionsArray_Count;

typedef struct ITMListSessionsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *windowsArray;
  NSMutableArray *buriedSessionsArray;
} ITMListSessionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "windowsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse_Window),
        .number = ITMListSessionsResponse_FieldNumber_WindowsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse__storage_, windowsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "buriedSessionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSessionSummary),
        .number = ITMListSessionsResponse_FieldNumber_BuriedSessionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse__storage_, buriedSessionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListSessionsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListSessionsResponse_Window

@implementation ITMListSessionsResponse_Window

@dynamic tabsArray, tabsArray_Count;
@dynamic hasWindowId, windowId;
@dynamic hasFrame, frame;

typedef struct ITMListSessionsResponse_Window__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tabsArray;
  NSString *windowId;
  ITMFrame *frame;
} ITMListSessionsResponse_Window__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMListSessionsResponse_Tab),
        .number = ITMListSessionsResponse_Window_FieldNumber_TabsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Window__storage_, tabsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMListSessionsResponse_Window_FieldNumber_WindowId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Window__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "frame",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMFrame),
        .number = ITMListSessionsResponse_Window_FieldNumber_Frame,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Window__storage_, frame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsResponse_Window class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListSessionsResponse_Window__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMListSessionsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMListSessionsResponse_Tab

@implementation ITMListSessionsResponse_Tab

@dynamic hasRoot, root;
@dynamic hasTabId, tabId;
@dynamic hasTmuxWindowId, tmuxWindowId;

typedef struct ITMListSessionsResponse_Tab__storage_ {
  uint32_t _has_storage_[1];
  NSString *tabId;
  ITMSplitTreeNode *root;
  NSString *tmuxWindowId;
} ITMListSessionsResponse_Tab__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabId",
        .dataTypeSpecific.className = NULL,
        .number = ITMListSessionsResponse_Tab_FieldNumber_TabId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Tab__storage_, tabId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "root",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMSplitTreeNode),
        .number = ITMListSessionsResponse_Tab_FieldNumber_Root,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Tab__storage_, root),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tmuxWindowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMListSessionsResponse_Tab_FieldNumber_TmuxWindowId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMListSessionsResponse_Tab__storage_, tmuxWindowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMListSessionsResponse_Tab class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMListSessionsResponse_Tab__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ITMListSessionsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCreateTabRequest

@implementation ITMCreateTabRequest

@dynamic hasProfileName, profileName;
@dynamic hasWindowId, windowId;
@dynamic hasTabIndex, tabIndex;
@dynamic hasCommand, command;
@dynamic customProfilePropertiesArray, customProfilePropertiesArray_Count;

typedef struct ITMCreateTabRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t tabIndex;
  NSString *profileName;
  NSString *windowId;
  NSString *command;
  NSMutableArray *customProfilePropertiesArray;
} ITMCreateTabRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "profileName",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabRequest_FieldNumber_ProfileName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCreateTabRequest__storage_, profileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabRequest_FieldNumber_WindowId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCreateTabRequest__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabIndex",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabRequest_FieldNumber_TabIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMCreateTabRequest__storage_, tabIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "command",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabRequest_FieldNumber_Command,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMCreateTabRequest__storage_, command),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "customProfilePropertiesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMProfileProperty),
        .number = ITMCreateTabRequest_FieldNumber_CustomProfilePropertiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMCreateTabRequest__storage_, customProfilePropertiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCreateTabRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCreateTabRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ITMCreateTabResponse

@implementation ITMCreateTabResponse

@dynamic hasStatus, status;
@dynamic hasWindowId, windowId;
@dynamic hasTabId, tabId;
@dynamic hasSessionId, sessionId;

typedef struct ITMCreateTabResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMCreateTabResponse_Status status;
  int32_t tabId;
  NSString *windowId;
  NSString *sessionId;
} ITMCreateTabResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMCreateTabResponse_Status_EnumDescriptor,
        .number = ITMCreateTabResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMCreateTabResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "windowId",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabResponse_FieldNumber_WindowId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMCreateTabResponse__storage_, windowId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabId",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabResponse_FieldNumber_TabId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ITMCreateTabResponse__storage_, tabId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ITMCreateTabResponse_FieldNumber_SessionId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ITMCreateTabResponse__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMCreateTabResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMCreateTabResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMCreateTabResponse_Status

GPBEnumDescriptor *ITMCreateTabResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000InvalidProfileName\000InvalidWindowId\000In"
        "validTabIndex\000MissingSubstitution\000";
    static const int32_t values[] = {
        ITMCreateTabResponse_Status_Ok,
        ITMCreateTabResponse_Status_InvalidProfileName,
        ITMCreateTabResponse_Status_InvalidWindowId,
        ITMCreateTabResponse_Status_InvalidTabIndex,
        ITMCreateTabResponse_Status_MissingSubstitution,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMCreateTabResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMCreateTabResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMCreateTabResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMCreateTabResponse_Status_Ok:
    case ITMCreateTabResponse_Status_InvalidProfileName:
    case ITMCreateTabResponse_Status_InvalidWindowId:
    case ITMCreateTabResponse_Status_InvalidTabIndex:
    case ITMCreateTabResponse_Status_MissingSubstitution:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSplitPaneRequest

@implementation ITMSplitPaneRequest

@dynamic hasSession, session;
@dynamic hasSplitDirection, splitDirection;
@dynamic hasBefore, before;
@dynamic hasProfileName, profileName;
@dynamic customProfilePropertiesArray, customProfilePropertiesArray_Count;

typedef struct ITMSplitPaneRequest__storage_ {
  uint32_t _has_storage_[1];
  ITMSplitPaneRequest_SplitDirection splitDirection;
  NSString *session;
  NSString *profileName;
  NSMutableArray *customProfilePropertiesArray;
} ITMSplitPaneRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = ITMSplitPaneRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSplitPaneRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "splitDirection",
        .dataTypeSpecific.enumDescFunc = ITMSplitPaneRequest_SplitDirection_EnumDescriptor,
        .number = ITMSplitPaneRequest_FieldNumber_SplitDirection,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ITMSplitPaneRequest__storage_, splitDirection),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "before",
        .dataTypeSpecific.className = NULL,
        .number = ITMSplitPaneRequest_FieldNumber_Before,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "profileName",
        .dataTypeSpecific.className = NULL,
        .number = ITMSplitPaneRequest_FieldNumber_ProfileName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ITMSplitPaneRequest__storage_, profileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "customProfilePropertiesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ITMProfileProperty),
        .number = ITMSplitPaneRequest_FieldNumber_CustomProfilePropertiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMSplitPaneRequest__storage_, customProfilePropertiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSplitPaneRequest class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSplitPaneRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSplitPaneRequest_SplitDirection

GPBEnumDescriptor *ITMSplitPaneRequest_SplitDirection_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Vertical\000Horizontal\000";
    static const int32_t values[] = {
        ITMSplitPaneRequest_SplitDirection_Vertical,
        ITMSplitPaneRequest_SplitDirection_Horizontal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSplitPaneRequest_SplitDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSplitPaneRequest_SplitDirection_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSplitPaneRequest_SplitDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSplitPaneRequest_SplitDirection_Vertical:
    case ITMSplitPaneRequest_SplitDirection_Horizontal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ITMSplitPaneResponse

@implementation ITMSplitPaneResponse

@dynamic hasStatus, status;
@dynamic sessionIdArray, sessionIdArray_Count;

typedef struct ITMSplitPaneResponse__storage_ {
  uint32_t _has_storage_[1];
  ITMSplitPaneResponse_Status status;
  NSMutableArray *sessionIdArray;
} ITMSplitPaneResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ITMSplitPaneResponse_Status_EnumDescriptor,
        .number = ITMSplitPaneResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ITMSplitPaneResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionIdArray",
        .dataTypeSpecific.className = NULL,
        .number = ITMSplitPaneResponse_FieldNumber_SessionIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ITMSplitPaneResponse__storage_, sessionIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ITMSplitPaneResponse class]
                                     rootClass:[ITMApiRoot class]
                                          file:ITMApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ITMSplitPaneResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ITMSplitPaneResponse_Status

GPBEnumDescriptor *ITMSplitPaneResponse_Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000SessionNotFound\000InvalidProfileName\000Ca"
        "nnotSplit\000MalformedCustomProfileProperty"
        "\000";
    static const int32_t values[] = {
        ITMSplitPaneResponse_Status_Ok,
        ITMSplitPaneResponse_Status_SessionNotFound,
        ITMSplitPaneResponse_Status_InvalidProfileName,
        ITMSplitPaneResponse_Status_CannotSplit,
        ITMSplitPaneResponse_Status_MalformedCustomProfileProperty,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ITMSplitPaneResponse_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ITMSplitPaneResponse_Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ITMSplitPaneResponse_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case ITMSplitPaneResponse_Status_Ok:
    case ITMSplitPaneResponse_Status_SessionNotFound:
    case ITMSplitPaneResponse_Status_InvalidProfileName:
    case ITMSplitPaneResponse_Status_CannotSplit:
    case ITMSplitPaneResponse_Status_MalformedCustomProfileProperty:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
