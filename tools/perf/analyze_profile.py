#!/usr/bin/env python3
"""
Analyze macOS sample profiler output for iTerm2.

Usage:
    python3 analyze_profile.py <profile_file>

Reads a profile file generated by the macOS `sample` command and
prints a summary of iTerm2-relevant hotspots and patterns.
"""

import os
import re
import sys


def analyze_profile(output_file):
    """Analyze the profile output for hotspots and inefficiencies."""
    print(f"\nAnalyzing profile: {output_file}")

    if not os.path.exists(output_file):
        print("Error: Profile output file not found")
        return False

    with open(output_file, 'r') as f:
        content = f.read()

    # Count occurrences of key patterns.
    patterns = {
        "boolForKey": r'\[iTermPreferences boolForKey:\]',
        "intForKey": r'\[iTermPreferences intForKey:\]',
        "objectForKey": r'\[iTermPreferences objectForKey:\]',
        "updateConfigurationFields": r'updateConfigurationFields',
        "NSUserDefaults": r'NSUserDefaults',
        "@synchronized": r'@synchronized',
        "os_unfair_lock": r'os_unfair_lock',
        # StringToScreenChars and text processing
        "StringToScreenChars": r'StringToScreenChars',
        "ScreenCharArray": r'ScreenCharArray',
        "bidi/Bidi": r'[Bb]idi',
        "VT100Terminal": r'VT100Terminal',
        "executeToken": r'executeToken',
        # Metal rendering
        "Metal": r'Metal|metal|MTL|CAMetalLayer',
        "iTermTextRenderer": r'iTermTextRenderer',
    }

    # Broader categories for spotting redundant work or churn.
    categories = {
        "Allocations": r'\b(malloc|calloc|realloc|free|operator new|operator delete)\b',
        "ObjC retain/release": r'objc_(retain|release|autoreleaseReturnValue|retainAutoreleasedReturnValue)',
        "Autorelease pools": r'NSAutoreleasePool|autoreleasepool',
        "Strings/Unicode": r'NSString|CFString|StringToScreenChars|ScreenCharArray',
        "CoreText": r'CTLine|CTRun|CTFont|CoreText',
        "CoreGraphics": r'CGContext|CGColor|CGPath|CGImage|CoreGraphics',
        "AppKit geometry": r'NSRect|NSMakeRect|convertRect|bounds|frame',
        "Locks/dispatch": r'os_unfair_lock|pthread_mutex|dispatch_semaphore|@synchronized',
        "Terminal parsing": r'VT100Parser|VT100Terminal|VT100Screen|executeToken',
        "Rendering": r'iTermTextRenderer|Metal|metal|MTL|CAMetalLayer',
        "Process/cache": r'iTermProcessCache|TaskNotifier|deepestForegroundJob',
    }

    print("\n" + "=" * 60)
    print("Profile Summary")
    print("=" * 60)

    for name, pattern in patterns.items():
        count = len(re.findall(pattern, content))
        print(f"  {name}: {count} occurrences")

    print("=" * 60)
    print("\n" + "=" * 60)
    print("Category Summary")
    print("=" * 60)
    for name, pattern in categories.items():
        count = len(re.findall(pattern, content))
        print(f"  {name}: {count} occurrences")
    print("=" * 60)

    # Extract top iTerm2 symbols from the call graph.
    symbol_pattern = re.compile(r'^\s*[+!:|]*\s*(\d+)\s+(.+?)\s+\(in iTerm2(?:\.debug\.dylib)?\)')
    counts = {}
    for line in content.splitlines():
        match = symbol_pattern.match(line)
        if not match:
            continue
        count = int(match.group(1))
        symbol = match.group(2).strip()
        if count > counts.get(symbol, 0):
            counts[symbol] = count

    if counts:
        print("\n" + "=" * 60)
        print("Top iTerm2 Symbols (by sample count)")
        print("=" * 60)
        for symbol, count in sorted(counts.items(), key=lambda item: item[1], reverse=True)[:15]:
            print(f"  {count}  {symbol}")
        print("=" * 60)

    print(f"\nFull profile saved to: {output_file}")
    return True


def main():
    if len(sys.argv) != 2:
        print("Usage: python3 analyze_profile.py <profile_file>")
        sys.exit(1)

    if not analyze_profile(sys.argv[1]):
        sys.exit(1)


if __name__ == "__main__":
    main()
